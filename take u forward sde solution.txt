1. Longest Consecutive Sequence: -

	int longestConsecutive(vector<int>& nums) 
    {
        int maxlen=0,len=0;
        unordered_set<int> us;
        for(int i=0;i<nums.size();i++)
            us.insert(nums[i]);
        for(int i=0;i<nums.size();i++)
        {
            if(us.find(nums[i]-1)!=us.end())
                continue;
            else
            {
                int val=nums[i];
                len=1;
                val++;
                while(us.find(val)!=us.end())
                {
                    len++;
                    val++;
                }
                if(maxlen<len)
                    maxlen=len;
            }
        }
        return maxlen;
    }

	2. Largest Subarray with 0 sum:-
	
	int maxLen(int A[], int n)
	{

    int sum=0,max_len=0;
    unordered_map<int,int> ump;
    for(int i=0;i<n;i++)
    {
        sum=sum+A[i];
        if(sum==0)
            max_len=i+1;
        if(A[i]==0 && max_len==0)
            max_len=1;
        if(ump.find(sum)!=ump.end())
        {
            max_len=max(max_len,i-ump[sum]);
        }
        else
            ump[sum]=i;
    }
    return max_len;
	}
	
3. Count number of subarrays with given XOR:-
	int Solve(vector<int> &A,int B)
	{
		int xor=0,count=0;
		unordered_map<int,int> ump;
		for(int i=0;i<A.size();i++)
		{
			xor=xor^A[i];
			if(xor==B)
				count++;
			if(ump.find(xor^B)!=ump.end())
			{
				count+=ump(xor^B);
			}
			ump[xor]+=1;
		}
		return count;
	}

4. Longest substring without repeat: -
  --------------------------------------
	int main() 
	{
	int t;
	cin>>t;
	while(t--)
	{
	    string str;
	    cin>>str;
	    unordered_map<char,int> ump;
	    int len=0;
	    int left=0,right=0;
	    while(right<str.length())
	    {
	        if(ump.find(str[right])!=ump.end())
                left=max(left,ump[str[right]]+1);
            ump[str[right]]=right;
            len=max(len,right-left+1);
            right++;
	    }
	    cout<<len<<endl;
	}
	return 0;
	}


Linked List : -
-------------------

1. Reverse a LinkedList : -
  --------------------------

    void reverse() 
    {  
	// Initialize current, previous and 
        // next pointers 
        Node* current = head; 
        Node *prev = NULL, *next = NULL; 
  
        while (current != NULL) { 
		// Store next 
            next = current->next; 
  
            // Reverse current node's pointer 
            current->next = prev; 
  
            // Move pointers one position ahead. 
            prev = current; 
            current = next; 
        } 
        head = prev; 
    } 
  
2. Find middle of LinkedList : -
  --------------------------------- 

void printMiddle(struct Node *head)  
{  
    struct Node *slow_ptr = head;  
    struct Node *fast_ptr = head;  
  
    if (head!=NULL)  
    {  
        while (fast_ptr != NULL && fast_ptr->next != NULL)  
        {  
            fast_ptr = fast_ptr->next->next;  
            slow_ptr = slow_ptr->next;  
        }  
        printf("The middle element is [%d]\n\n", slow_ptr->data);  
    }  
}

3. Merge two sorted Linked List : -
  ----------------------------------

Node* Merge(Node *l1,Node *l2)
{
	//iterative
	if(l1==	NULL)
		return l2;
	if(l2==NULL)
		return l1;	
	if(l1->data>l2->data)
		swap(l1,l2);
	Node *res=l1;
	while(l1!=NULL && l2!=NULL)
	{
		Node *tmp=NULL;
		while(l1!=NULL && l1->data<=l2->data)
		{
			tmp=l1;
			l1=l1->next;
		}
		tmp->next=l2;
		swap(l1,l2);
	
	}
	return res;
}

4. Remove N-th node from back of LinkedList : -
  -----------------------------------------------

Node* removeNthNode(Node *head, int n)
{
	Node *start=new Node();
	start->next=head;
	Node *fast=start;
	Node *slow=start;
	for(int i=1;i<=n;i++)
		fast=fast->next;	
	while(fast->next!=NULL)
	{
		fast=fast->next;
		slow=slow->next;
	}
	slow->next=slow->next->next;
	return start->next;	

}

5. Delete a given Node when a node is given. (0(1) solution) : -
  -----------------------------------------------------------------
node_ptr=pointer to node which is to be deleted

void deleteNode(Node *node_ptr)  
{  
    if(node_ptr->next==NULL)
    {
	node_ptr=NULL;
	return;
    }
    Node *temp = node_ptr->next;  
    node_ptr->data = temp->data;  
    node_ptr->next = temp->next;  
    free(temp);  
}  

6.  Add two numbers as LinkedList:-
   -----------------------------------

void LinkedList::sum(LinkedList* l2) 
{ 
    reverse(); 
    l2->reverse(); 
  
    Node *start1 = head, *start2 = l2->head; 
  
    Node* prev = NULL; 
    int carry = 0; 
  
    // While both lists exist 
    while (start1 && start2) { 
  
        // Current sum 
        int temp = start1->data + start2->data + carry; 
  
        // Handle carry 
        start1->data = temp % 10; 
        carry = temp / 10; 
        prev = start1; 
  
        // Get to next nodes 
        start1 = start1->next; 
        start2 = start2->next; 
    } 
  
    // If there are reamining digits 
    // in any one of the lists 
    if (start1 || start2) { 
  
        if (start2) 
            prev->next = start2; 
  
        start1 = prev->next; 
  
        // While first list has digits remaining 
        while (start1) { 
            int temp = start1->data + carry; 
            start1->data = temp % 10; 
            carry = temp / 10; 
            prev = start1; 
            start1 = start1->next; 
        } 
    } 
  
    // If a new node needs to be 
    // created due to carry 
    if (carry > 0) { 
        prev->next = new Node(carry); 
    } 
  
    // Reverse the resultant list 
    reverse(); 
} 
  
// Driver code 
int main() 
{ 
  
    // Create first list 
    LinkedList* l1 = new LinkedList(); 
    l1->insert(3); 
    l1->insert(6); 
    l1->insert(5); 
  
    // Create second list 
    LinkedList* l2 = new LinkedList(); 
    l2->insert(2); 
    l2->insert(4); 
    l2->insert(8); 
  
    // Add the lists 
    l1->sum(l2); 
    return 0; 
} 

Time Complexity: O(max(m, n)) where m and n are number of nodes in list l1 and list l2 respectively.
Space Complexity: O(1)

7. Find intersection point of Y LinkedList : -
  ----------------------------------------------

int getIntesectionNode(Node* head1, Node* head2) 
{ 
  
    // Count the number of nodes in 
    // both the linked list 
    int c1 = getCount(head1); 
    int c2 = getCount(head2); 
    int d; 
  
    // If first is greater 
    if (c1 > c2) { 
        d = c1 - c2; 
        return _getIntesectionNode(d, head1, head2); 
    } 
    else { 
        d = c2 - c1; 
        return _getIntesectionNode(d, head2, head1); 
    } 
} 
  
/* function to get the intersection point of two linked  
lists head1 and head2 where head1 has d more nodes than  
head2 */
int _getIntesectionNode(int d, Node* head1, Node* head2) 
{ 
    // Stand at the starting of the bigger list 
    Node* current1 = head1; 
    Node* current2 = head2; 
  
    // Move the pointer forward 
    for (int i = 0; i < d; i++) { 
        if (current1 == NULL) { 
            return -1; 
        } 
        current1 = current1->next; 
    } 
  
    // Move both pointers of both list till they 
    // intersect with each other 
    while (current1 != NULL && current2 != NULL) { 
        if (current1 == current2) 
            return current1->data; 
  
        // Move both the pointers forward 
        current1 = current1->next; 
        current2 = current2->next; 
    } 
  
    return -1; 
} 
  
/* Takes head pointer of the linked list and  
returns the count of nodes in the list */
int getCount(Node* head) 
{ 
    Node* current = head; 
  
    // Counter to store count of nodes 
    int count = 0; 
  
    // Iterate till NULL 
    while (current != NULL) { 
  
        // Increase the counter 
        count++; 
  
        // Move the Node ahead 
        current = current->next; 
    } 
  
    return count; 
} 
  
// Driver Code 
int main() 
{ 
    /*  
        Create two linked lists  
      
        1st 3->6->9->15->30  
        2nd 10->15->30  
      
        15 is the intersection point  
    */
  
    Node* newNode; 
  
    // Addition of new nodes 
    Node* head1 = new Node(); 
    head1->data = 10; 
  
    Node* head2 = new Node(); 
    head2->data = 3; 
  
    newNode = new Node(); 
    newNode->data = 6; 
    head2->next = newNode; 
  
    newNode = new Node(); 
    newNode->data = 9; 
    head2->next->next = newNode; 
  
    newNode = new Node(); 
    newNode->data = 15; 
    head1->next = newNode; 
    head2->next->next->next = newNode; 
  
    newNode = new Node(); 
    newNode->data = 30; 
    head1->next->next = newNode; 
  
    head1->next->next->next = NULL; 
  
    cout << "The node of intersection is " << getIntesectionNode(head1, head2); 
}

8. Check if a LinkedList is palindrome or not: -
  -----------------------------------------------

bool isPalindrome(struct Node* head)  
{
	Node *secondHead, *slow_ptr=head,*fast_ptr=head;
	while(1)
	{
		fast_ptr=fast_ptr->next->next;
		if(fast_ptr->next==NULL)
		{
			secondHead=slow_ptr->next->next;
			break;
		}
		if(fast_ptr==NULL)
		{
			secondHead=slow_ptr->next;
			break;
		}
		slow_ptr=slow_ptr->next;
	}
	slow_ptr->next=NULL;
	reverse(&secondHead);
	return compareList(head,secondHead);
}
void reverse(struct Node** head_ref)  
{  
    struct Node* prev = NULL;  
    struct Node* current = *head_ref;  
    struct Node* next;  
    while (current != NULL) {  
        next = current->next;  
        current->next = prev;  
        prev = current;  
        current = next;  
    }  
    *head_ref = prev;  
}  
  
/* Function to check if two input lists have same data*/
bool compareLists(struct Node* head1, struct Node* head2)  
{  
    struct Node* temp1 = head1;  
    struct Node* temp2 = head2;  
  
    while (temp1 && temp2) {  
        if (temp1->data == temp2->data) {  
            temp1 = temp1->next;  
            temp2 = temp2->next;  
        }  
        else
            return 0;  
    }  
  
    /* Both are empty reurn 1*/
    if (temp1 == NULL && temp2 == NULL)  
        return 1;  
  
    /* Will reach here when one is NULL  
    and other is not */
    return 0;  
}  

9. Reverse a LinkedList in groups : -
  -------------------------------------

int main()  
{
	//after inserting all elements in linked list
	head = reverse(head, 3);
	return(0);  
}  
Node *reverse (Node *head, int k)  
{  
    Node* current = head;  
    Node* next = NULL;  
    Node* prev = NULL;  
    int count = 0;  
      
    /*reverse first k nodes of the linked list */
    while (current != NULL && count < k)  
    {  
        next = current->next;  
        current->next = prev;  
        prev = current;  
        current = next;  
        count++;  
    }  
      
    /* next is now a pointer to (k+1)th node  
    Recursively call for the list starting from current.  
    And make rest of the list as next of first node */
    if (next != NULL)  
    head->next = reverse(next, k);  
  
    /* prev is new head of the input list */
    return prev;  
}

10. Detect a cycle and removing loop(two different questions and same concept) :-
   -----------------------------------------------------------------------------------

void detectAndRemoveLoop(Node* head) 
{ 
    // If list is empty or has only one node 
    // without loop 
    if (head == NULL || head->next == NULL) 
        return; 
  
    Node *slow = head, *fast = head; 
  
    // Move slow and fast 1 and 2 steps 
    // ahead respectively. 
    slow = slow->next; 
    fast = fast->next->next; 
  
    // Search for loop using slow and 
    // fast pointers 
    while (fast && fast->next) { 
        if (slow == fast) 
            break; 
        slow = slow->next; 
        fast = fast->next->next; 
    } 
  
    /* If loop exists this will remove loop.*/
    if (slow == fast) { 
        slow = head; 
        while (slow->next != fast->next) { 
            slow = slow->next; 
            fast = fast->next; 
        } 
  	//Starting point of loop is slow->next if we need to find starting point of loop we can 	//return slow->next but here we are removing loop so we are making its last node point 		//to null.
        
	/* since fast->next is the looping point */
        fast->next = NULL; /* remove loop */
    } 
} 

11. Flattening of a LinkedList:-
   ------------------------------

int main() 
{
	//inserting nodes steps are skipped
	root = flatten(root); 
	return 0; 
} 

Node* merge( Node* a, Node* b ) 
{ 
    // If first list is empty, the second list is result 
    if (a == NULL) 
        return b; 
  
    // If second list is empty, the second list is result 
    if (b == NULL) 
        return a; 
  
    // Compare the data members of head nodes of both lists 
    // and put the smaller one in result 
    Node* result; 
    if (a->data < b->data) 
    { 
        result = a; 
        result->down = merge( a->down, b ); 
    } 
    else
    { 
        result = b; 
        result->down = merge( a, b->down ); 
    } 
  
    result->right = NULL; 
    return result; 
} 
  
// The main function that flattens a given linked list 
Node* flatten (Node* root) 
{ 
    // Base cases 
    if (root == NULL || root->right == NULL) 
        return root; 
  
    // Merge this list with the list on right side 
    return merge( root, flatten(root->right) ); 
} 

12. Rotate a LinkedList: -
   ------------------------
	
void rotate(Node** head_ref, int k)
{
    if (k == 0)
        return;
 
    // Let us understand the below
    // code for example k = 4 and
    // list = 10->20->30->40->50->60.
    Node* current = *head_ref;
 
    // current will either point to
    // kth or NULL after this loop.
    // current will point to node
    // 40 in the above example
    int count = 1;
    while (count < k && current != NULL) {
        current = current->next;
        count++;
    }
 
    // If current is NULL, k is greater than
    // or equal to count of nodes in linked list.
    // Don't change the list in this case
    if (current == NULL)
        return;
 
    // current points to kth node.
    // Store it in a variable. kthNode
    // points to node 40 in the above example
    Node* kthNode = current;
 
    // current will point to
    // last node after this loop
    // current will point to
    // node 60 in the above example
    while (current->next != NULL)
        current = current->next;
 
    // Change next of last node to previous head
    // Next of 60 is now changed to node 10
    current->next = *head_ref;
 
    // Change head to (k+1)th node
    // head is now changed to node 50
    *head_ref = kthNode->next;
 
    // change next of kth node to NULL
    // next of 40 is now NULL
    kthNode->next = NULL;
}

13. Clone a Linked List with random and next pointer: -
   -------------------------------------------------------

Node* clone(Node *start) 
{ 
    Node* curr = start, *temp; 
  
    // insert additional node after 
    // every node of original list 
    while (curr) 
    { 
        temp = curr->next; 
  
        // Inserting node 
        curr->next = new Node(curr->data); 
        curr->next->next = temp; 
        curr = temp; 
    } 
  
    curr = start; 
  
    // adjust the random pointers of the 
    // newly added nodes 
    while (curr) 
    { 
        if(curr->next) 
            curr->next->random = curr->random ?  
                                 curr->random->next : curr->random; 
  
        // move to the next newly added node by 
        // skipping an original node 
        curr = curr->next?curr->next->next:curr->next; 
    } 
  
    Node* original = start, *copy = start->next; 
  
    // save the start of copied linked list 
    temp = copy; 
  
    // now separate the original list and copied list 
    while (original && copy) 
    { 
        original->next = 
         original->next? original->next->next : original->next; 
  
        copy->next = copy->next?copy->next->next:copy->next; 
        original = original->next; 
        copy = copy->next; 
    } 
  
    return temp; 
} 

=> 2-pointer :-
   ------------
 
1. Merge two sorted LinkedLists: -
  ----------------------------------
Node* SortedMerge(Node* a, Node* b) 
{ 
    Node* result = NULL; 
     
    /* Base cases */
    if (a == NULL) 
        return(b); 
    else if (b == NULL) 
        return(a); 
     
    /* Pick either a or b, and recur */
    if (a->data <= b->data) 
    { 
        result = a; 
        result->next = SortedMerge(a->next, b); 
    } 
    else
    { 
        result = b; 
        result->next = SortedMerge(a, b->next); 
    } 
    return(result); 
} 

2. Find the starting point of the loop :-
  ----------------------------------------
//Already done this in detect and remove loop only we need to change a line here

void detectAndStartOfLoop(Node* head) 
{ 
    // If list is empty or has only one node 
    // without loop 
    if (head == NULL || head->next == NULL) 
        return; 
  
    Node *slow = head, *fast = head; 
  
    // Move slow and fast 1 and 2 steps 
    // ahead respectively. 
    slow = slow->next; 
    fast = fast->next->next; 
  
    // Search for loop using slow and 
    // fast pointers 
    while (fast && fast->next) { 
        if (slow == fast) 
            break; 
        slow = slow->next; 
        fast = fast->next->next; 
    } 
  
    /* If loop exists this will remove loop.*/
    if (slow == fast) { 
        slow = head; 
        while (slow->next != fast->next) { 
            slow = slow->next; 
            fast = fast->next; 
        } 
  	//Starting point of loop is fast->next if we need to find starting point of loop we can 	//return fast->next but here we are removing loop so we are making its last node point 		//to null.
        
	Node *startingPoint=fast->next; //we can also write startingPoint=slow->next both will 						//give same answer
	return startingPoint;
    } 
} 

3. 3 sum :-
  ------------

bool find3Numbers(int A[], int arr_size, int sum) 
{ 
    int l, r; 
  
    /* Sort the elements */
    sort(A, A + arr_size); 
  
    /* Now fix the first element one by one and find the 
       other two elements */
    for (int i = 0; i < arr_size - 2; i++) { 
  
        // To find the other two elements, start two index 
        // variables from two corners of the array and move 
        // them toward each other 
        l = i + 1; // index of the first element in the 
        // remaining elements 
  
        r = arr_size - 1; // index of the last element 
        while (l < r) { 
            if (A[i] + A[l] + A[r] == sum) { 
                printf("Triplet is %d, %d, %d", A[i], 
                       A[l], A[r]); 
                return true; 
            } 
            else if (A[i] + A[l] + A[r] < sum) 
                l++; 
            else // A[i] + A[l] + A[r] > sum 
                r--; 
        } 
    } 
  
    // If we reach here, then no triplet was found 
    return false; 
} 

4. Trapping rainwater:-
  ----------------------

  #include <iostream> 
using namespace std; 
  
int findWater(int arr[], int n) 
{ 
    // initialize output 
    int result = 0; 
  
    // maximum element on left and right 
    int left_max = 0, right_max = 0; 
  
    // indices to traverse the array 
    int lo = 0, hi = n - 1; 
  
    while (lo <= hi) { 
        if (arr[lo] < arr[hi]) { 
            if (arr[lo] > left_max) 
                // update max in left 
                left_max = arr[lo]; 
            else
                // water on curr element = max - curr 
                result += left_max - arr[lo]; 
            lo++; 
        } 
        else { 
            if (arr[hi] > right_max) 
                // update right maximum 
                right_max = arr[hi]; 
            else
                result += right_max - arr[hi]; 
            hi--; 
        } 
    } 
  
    return result; 
} 

Complexity Analysis: 
Time Complexity: O(n). 
Only one traversal of the array is needed.
Auxiliary Space: O(1). 
As no extra space is required.

5. Remove Duplicate from Sorted array:-
  ----------------------------------------

int removeDuplicates(int arr[], int n) 
{ 
    // Return, if array is empty 
    // or contains a single element 
    if (n==0 || n==1) 
        return n; 
  
    int temp[n]; 
  
    // Start traversing elements 
    int j = 0; 
    for (int i=0; i<n-1; i++) 
  
        // If current element is not equal 
        // to next element then store that 
        // current element 
        if (arr[i] != arr[i+1]) 
            temp[j++] = arr[i]; 
  
    // Store the last element as whether 
    // it is unique or repeated, it hasn't 
    // stored previously 
    temp[j++] = arr[n-1]; 
  
    // Modify original array 
    for (int i=0; i<j; i++) 
        arr[i] = temp[i]; 
  
    return j; 
} 

6. Max continuous number of 1’s :-
  -----------------------------------
  
  int getMaxLength(int arr[], int n) 
{ 
    int count = 0; //intitialize count 
    int result = 0; //initialize max 
  
    for (int i = 0; i < n; i++) 
    { 
        // Reset count when 0 is found 
        if (arr[i] != 1) 
            count = 0; 
  
        // If 1 is found, increment count 
        // and update result if count becomes 
        // more. 
        else
        { 
            count++;//increase count 
            result = max(result, count); 
        } 
    } 
  
    return result; 
} 

=>  Greedy:-
   -----------
1. N meeting in one room:-
  --------------------------
  
#include <bits/stdc++.h> 
using namespace std; 
 
// Structure for storing starting time, 
// finishing time and position of meeting. 
struct meeting { 
    int start; 
    int end; 
    int pos; 
}; 
 
// Comparator function which can compare 
// the second element of structure used to 
// sort pairs in increasing order of second value. 
bool comparator(struct meeting m1, meeting m2) 
{ 
    return (m1.end < m2.end); 
} 
 
// Function for finding maximum meeting in one room 
void maxMeeting(int s[], int f[], int n) 
{ 
    struct meeting meet[n]; 
    for (int i = 0; i < n; i++) 
    { 
        // Starting time of meeting i. 
        meet[i].start = s[i]; 
         
        // Finishing time of meeting i 
        meet[i].end = f[i]; 
         
        // Original position/index of meeting 
        meet[i].pos = i + 1; 
    } 
 
    // Sorting of meeting according to their finish time. 
    sort(meet, meet + n, comparator); 
 
    // Vector for storing selected meeting. 
    vector<int> m; 
 
    // Initially select first meeting. 
    m.push_back(meet[0].pos); 
 
    // time_limit to check whether new 
    // meeting can be conducted or not. 
    int time_limit = meet[0].end; 
 
    // Check for all meeting whether it 
    // can be selected or not. 
    for (int i = 1; i < n; i++) { 
        if (meet[i].start >= time_limit) 
        { 
            // Push selected meeting to vector 
            m.push_back(meet[i].pos); 
             
            // Update time limit. 
            time_limit = meet[i].end; 
        } 
    } 
 
    // Print final selected meetings. 
    for (int i = 0; i < m.size(); i++) { 
        cout << m[i] << " "; 
    } 
} 
 
// Driver code 
int main() 
{ 
    // Starting time 
    int s[] = { 1, 3, 0, 5, 8, 5 }; 
     
    // Finish time 
    int f[] = { 2, 4, 6, 7, 9, 9 }; 
     
    // Number of meetings. 
    int n = sizeof(s) / sizeof(s[0]); 
 
    // Function call 
    maxMeeting(s, f, n); 
 
    return 0; 
} 

2. Activity Selection :-
  ------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
// A job has a start time, finish time and profit. 
struct Activitiy 
{ 
    int start, finish; 
}; 
  
// A utility function that is used for sorting 
// activities according to finish time 
bool activityCompare(Activitiy s1, Activitiy s2) 
{ 
    return (s1.finish < s2.finish); 
} 
  
// Returns count of the maximum set of activities that can 
// be done by a single person, one at a time. 
void printMaxActivities(Activitiy arr[], int n) 
{ 
    // Sort jobs according to finish time 
    sort(arr, arr+n, activityCompare); 
  
    cout << "Following activities are selected n"; 
  
    // The first activity always gets selected 
    int i = 0; 
    cout << "(" << arr[i].start << ", " << arr[i].finish << "), "; 
  
    // Consider rest of the activities 
    for (int j = 1; j < n; j++) 
    { 
      // If this activity has start time greater than or 
      // equal to the finish time of previously selected 
      // activity, then select it 
      if (arr[j].start >= arr[i].finish) 
      { 
          cout << "(" << arr[j].start << ", "
              << arr[j].finish << "), "; 
          i = j; 
      } 
    } 
} 
  
// Driver program 
int main() 
{ 
    Activitiy arr[] = {{5, 9}, {1, 2}, {3, 4}, {0, 6}, 
                                       {5, 7}, {8, 9}}; 
    int n = sizeof(arr)/sizeof(arr[0]); 
    printMaxActivities(arr, n); 
    return 0; 
} 

3. Greedy algorithm to find minimum number of coins:-
  -----------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
// All denominations of Indian Currency 
int deno[] = { 1, 2, 5, 10, 20, 
               50, 100, 500, 1000 }; 
int n = sizeof(deno) / sizeof(deno[0]); 
  
void findMin(int V) 
{ 
    sort(deno, deno + n); 
  
    // Initialize result 
    vector<int> ans; 
  
    // Traverse through all denomination 
    for (int i = n - 1; i >= 0; i--) { 
  
        // Find denominations 
        while (V >= deno[i]) { 
            V -= deno[i]; 
            ans.push_back(deno[i]); 
        } 
    } 
  
    // Print result 
    for (int i = 0; i < ans.size(); i++) 
        cout << ans[i] << " "; 
} 
  
// Driver program 
int main() 
{ 
    int n = 93; 
    cout << "Following is minimal"
         << " number of change for " << n 
         << ": "; 
    findMin(n); 
    return 0; 
} 

Complexity Analysis:-
--------------------
Time Complexity: O(V).
Auxiliary Space: O(1) as no additional space is used.


4. Fractional Knapsack Problem:-
  -------------------------------

#include <bits/stdc++.h>
 
using namespace std;
 
// Structure for an item which stores weight and
// corresponding value of Item
struct Item 
{
    int value, weight;
 
    // Constructor
    Item(int value, int weight)
        : value(value)
        , weight(weight)
    {
    }
};
 
// Comparison function to sort Item according to val/weight
// ratio
bool cmp(struct Item a, struct Item b)
{
    double r1 = (double)a.value / (double)a.weight;
    double r2 = (double)b.value / (double)b.weight;
    return r1 > r2;
}
 
// Main greedy function to solve problem
double fractionalKnapsack(int W, struct Item arr[], int n)
{
    //    sorting Item on basis of ratio
    sort(arr, arr + n, cmp);
    int curWeight = 0; // Current weight in knapsack
    double finalvalue = 0.0; // Result (value in Knapsack)
    // Looping through all Items
    for (int i = 0; i < n; i++) 
    {
        // If adding Item won't overflow, add it completely
        if (curWeight + arr[i].weight <= W) 
        {
            curWeight += arr[i].weight;
            finalvalue += arr[i].value;
        }
        // If we can't add current Item, add fractional part
        // of it
        else
        {
            int remain = W - curWeight;
            finalvalue
                += arr[i].value
                   * ((double)remain / (double)arr[i].weight);
            break;
        }
    }
 
    // Returning final value
    return finalvalue;
}
 
5. Minimum number of platforms required for a railway:-
  --------------------------------------------------------
 
int minPlatform(int arrival[], int departure[], int n) 
{ 
  
    // as time range from 0 to 2359 in 24 hour clock, 
    // we declare an array for values from 0 to 2360 
    int platform[2361] = {0}; 
    int requiredPlatform = 1; 
    for (int i = 0; i < n; i++) { 
  
        // increment the platforms for arrival 
        ++platform[arrival[i]];  
  
         // once train departs we decrease the platform count 
        --platform[departure[i] + 1]; 
    } 
  
    // We are running loop till 2361 because maximum time value 
    // in a day can be 23:60 
    for (int i = 1; i < 2361; i++) { 
  
        // taking cumulative sum of platform give us required 
        // number of platform fro every minute 
        platform[i] = platform[i] + platform[i - 1];  
        requiredPlatform = max(requiredPlatform, platform[i]); 
    } 
    return requiredPlatform; 
} 

6. Job sequencing Problem:-
  --------------------------
#include<iostream>
#include<algorithm>
using namespace std;
 
// A structure to represent a job
struct Job
{
   char id;     // Job Id
   int dead;    // Deadline of job
   int profit;  // Profit if job is over before or on deadline
};
 
// This function is used for sorting all jobs according to profit
bool comparison(Job a, Job b)
{
     return (a.profit > b.profit);
}
 
// Returns minimum number of platforms reqquired
void printJobScheduling(Job arr[], int n)
{
    // Sort all jobs according to decreasing order of prfit
    sort(arr, arr+n, comparison);
 
    int result[n]; // To store result (Sequence of jobs)
    bool slot[n];  // To keep track of free time slots
 
    // Initialize all slots to be free
    for (int i=0; i<n; i++)
        slot[i] = false;
 
    // Iterate through all given jobs
    for (int i=0; i<n; i++)
    {
       // Find a free slot for this job (Note that we start
       // from the last possible slot)
       for (int j=min(n, arr[i].dead)-1; j>=0; j--)
       {
          // Free slot found
          if (slot[j]==false)
          {
             result[j] = i;  // Add this job to result
             slot[j] = true; // Make this slot occupied
             break;
          }
       }
    }
 
    // Print the result
    for (int i=0; i<n; i++)
       if (slot[i])
         cout << arr[result[i]].id << " ";
}


==> Backtracking:-
   ----------------

1. N queens Problem:-
  --------------------

#define N 4 
#include <stdbool.h> 
#include <stdio.h> 
/* ld is an array where its indices indicate row-col+N-1 
 (N-1) is for shifting the difference to store negative  
 indices */
int ld[30] = { 0 }; 
/* rd is an array where its indices indicate row+col 
   and used to check whether a queen can be placed on  
   right diagonal or not*/
int rd[30] = { 0 }; 
/*column array where its indices indicates column and  
  used to check whether a queen can be placed in that 
    row or not*/
int cl[30] = { 0 }; 
/* A utility function to print solution */
void printSolution(int board[N][N]) 
{ 
    for (int i = 0; i < N; i++) { 
        for (int j = 0; j < N; j++) 
            printf(" %d ", board[i][j]); 
        printf("\n"); 
    } 
} 
  
/* A recursive utility function to solve N 
   Queen problem */
bool solveNQUtil(int board[N][N], int col) 
{ 
    /* base case: If all queens are placed 
      then return true */
    if (col >= N) 
        return true; 
  
    /* Consider this column and try placing 
       this queen in all rows one by one */
    for (int i = 0; i < N; i++) { 
        /* Check if the queen can be placed on 
          board[i][col] */
        /* A check if a queen can be placed on  
           board[row][col].We just need to check 
           ld[row-col+n-1] and rd[row+coln] where 
           ld and rd are for left and right  
           diagonal respectively*/
        if ((ld[i - col + N - 1] != 1 && 
                  rd[i + col] != 1) && cl[i] != 1) { 
            /* Place this queen in board[i][col] */
            board[i][col] = 1; 
            ld[i - col + N - 1] = 
                          rd[i + col] = cl[i] = 1; 
  
            /* recur to place rest of the queens */
            if (solveNQUtil(board, col + 1)) 
                return true; 
  
            /* If placing queen in board[i][col] 
               doesn't lead to a solution, then 
               remove queen from board[i][col] */
            board[i][col] = 0; // BACKTRACK 
            ld[i - col + N - 1] = 
                         rd[i + col] = cl[i] = 0; 
        } 
    } 
  
    /* If the queen cannot be placed in any row in 
        this colum col  then return false */
    return false; 
} 
/* This function solves the N Queen problem using 
   Backtracking. It mainly uses solveNQUtil() to  
   solve the problem. It returns false if queens 
   cannot be placed, otherwise, return true and 
   prints placement of queens in the form of 1s. 
   Please note that there may be more than one 
   solutions, this function prints one  of the 
   feasible solutions.*/
bool solveNQ() 
{ 
    int board[N][N] = { { 0, 0, 0, 0 }, 
                        { 0, 0, 0, 0 }, 
                        { 0, 0, 0, 0 }, 
                        { 0, 0, 0, 0 } }; 
  
    if (solveNQUtil(board, 0) == false) { 
        printf("Solution does not exist"); 
        return false; 
    } 
  
    printSolution(board); 
    return true; 
} 
  
// driver program to test above function 
int main() 
{ 
    solveNQ(); 
    return 0; 
} 

2. Sudoko:-
  -----------

 #include <bits/stdc++.h> 
using namespace std; 
  
// UNASSIGNED is used for empty 
// cells in sudoku grid 
#define UNASSIGNED 0 
  
// N is used for the size of Sudoku grid. 
// Size will be NxN 
#define N 9 
  
// This function finds an entry in grid 
// that is still unassigned 
bool FindUnassignedLocation(int grid[N][N], 
                            int& row, int& col); 
  
// Checks whether it will be legal 
// to assign num to the given row, col 
bool isSafe(int grid[N][N], int row, 
            int col, int num); 
  
/* Takes a partially filled-in grid and attempts  
to assign values to all unassigned locations in  
such a way to meet the requirements for 
Sudoku solution (non-duplication across rows, 
columns, and boxes) */
bool SolveSudoku(int grid[N][N]) 
{ 
    int row, col; 
  
    // If there is no unassigned location, 
    // we are done 
    if (!FindUnassignedLocation(grid, row, col)) 
        // success! 
        return true; 
  
    // Consider digits 1 to 9 
    for (int num = 1; num <= 9; num++)  
    { 
          
        // Check if looks promising 
        if (isSafe(grid, row, col, num))  
        { 
              
            // Make tentative assignment 
            grid[row][col] = num; 
  
            // Return, if success 
            if (SolveSudoku(grid)) 
                return true; 
  
            // Failure, unmake & try again 
            grid[row][col] = UNASSIGNED; 
        } 
    } 
     
    // This triggers backtracking 
    return false; 
} 
  
/* Searches the grid to find an entry that is  
still unassigned. If found, the reference  
parameters row, col will be set the location  
that is unassigned, and true is returned.  
If no unassigned entries remain, false is returned. */
bool FindUnassignedLocation(int grid[N][N], 
                            int& row, int& col) 
{ 
    for (row = 0; row < N; row++) 
        for (col = 0; col < N; col++) 
            if (grid[row][col] == UNASSIGNED) 
                return true; 
    return false; 
} 
  
/* Returns a boolean which indicates whether  
an assigned entry in the specified row matches 
the given number. */
bool UsedInRow(int grid[N][N], int row, int num) 
{ 
    for (int col = 0; col < N; col++) 
        if (grid[row][col] == num) 
            return true; 
    return false; 
} 
  
/* Returns a boolean which indicates whether  
an assigned entry in the specified column 
matches the given number. */
bool UsedInCol(int grid[N][N], int col, int num) 
{ 
    for (int row = 0; row < N; row++) 
        if (grid[row][col] == num) 
            return true; 
    return false; 
} 
  
/* Returns a boolean which indicates whether  
an assigned entry within the specified 3x3 box  
matches the given number. */
bool UsedInBox(int grid[N][N], int boxStartRow, 
               int boxStartCol, int num) 
{ 
    for (int row = 0; row < sqrt(N); row++) 
        for (int col = 0; col < sqrt(N); col++) 
            if (grid[row + boxStartRow][col + boxStartCol] ==num) 
                return true; 
    return false; 
} 
  
/* Returns a boolean which indicates whether  
it will be legal to assign num to the given  
row, col location. */
bool isSafe(int grid[N][N], int row, 
            int col, int num) 
{ 
    /* Check if 'num' is not already placed in  
    current row, current column  
    and current 3x3 box */
    return !UsedInRow(grid, row, num) 
           && !UsedInCol(grid, col, num) 
           && !UsedInBox(grid, row - row % sqrt(N), 
                         col - col % sqrt(N), num) 
           && grid[row][col] == UNASSIGNED; 
} 
  
/* A utility function to print grid */
void printGrid(int grid[N][N]) 
{ 
    for (int row = 0; row < N; row++)  
    { 
        for (int col = 0; col < N; col++) 
            cout << grid[row][col] << " "; 
        cout << endl; 
    } 
} 
  
// Driver Code 
int main() 
{ 
    // 0 means unassigned cells 
    int grid[N][N] = { { 3, 0, 6, 5, 0, 8, 4, 0, 0 }, 
                       { 5, 2, 0, 0, 0, 0, 0, 0, 0 }, 
                       { 0, 8, 7, 0, 0, 0, 0, 3, 1 }, 
                       { 0, 0, 3, 0, 1, 0, 0, 8, 0 }, 
                       { 9, 0, 0, 8, 6, 3, 0, 0, 5 }, 
                       { 0, 5, 0, 0, 9, 0, 6, 0, 0 }, 
                       { 1, 3, 0, 0, 0, 0, 2, 5, 0 }, 
                       { 0, 0, 0, 0, 0, 0, 0, 7, 4 }, 
                       { 0, 0, 5, 2, 0, 6, 3, 0, 0 } }; 
    if (SolveSudoku(grid) == true) 
        printGrid(grid); 
    else
        cout << "No solution exists"; 
  
    return 0; 
}

3. M coloring Problem (Graph prob):-
  -------------------------------------
  
  #include <stdbool.h>
#include <stdio.h>
 
// Number of vertices in the graph
#define V 4
 
void printSolution(int color[]);
 
/* A utility function to check if 
   the current color assignment
   is safe for vertex v i.e. checks 
   whether the edge exists or not
   (i.e, graph[v][i]==1). If exist 
   then checks whether the color to 
   be filled in the new vertex(c is
   sent in the parameter) is already
   used by its adjacent 
   vertices(i-->adj vertices) or 
   not (i.e, color[i]==c) */
bool isSafe(
    int v, bool graph[V][V],
    int color[], int c)
{
    for (int i = 0; i < V; i++)
        if (
            graph[v][i] && c == color[i])
            return false;
    return true;
}
 
/* A recursive utility function 
to solve m coloring problem */
bool graphColoringUtil(
    bool graph[V][V], int m,
    int color[], int v)
{
    /* base case: If all vertices are 
       assigned a color then return true */
    if (v == V)
        return true;
 
    /* Consider this vertex v and 
       try different colors */
    for (int c = 1; c <= m; c++) {
        /* Check if assignment of color 
           c to v is fine*/
        if (isSafe(
                v, graph, color, c)) {
            color[v] = c;
 
            /* recur to assign colors to 
               rest of the vertices */
            if (
                graphColoringUtil(
                    graph, m, color, v + 1)
                == true)
                return true;
 
            /* If assigning color c doesn't
               lead to a solution then remove it */
            color[v] = 0;
        }
    }
 
    /* If no color can be assigned to 
       this vertex then return false */
    return false;
}
 
/* This function solves the m Coloring 
   problem using Backtracking. It mainly 
   uses graphColoringUtil() to solve the 
   problem. It returns false if the m 
   colors cannot be assigned, otherwise 
   return true and prints assignments of 
   colors to all vertices. Please note 
   that there may be more than one solutions,
   this function prints one of the
   feasible solutions.*/
bool graphColoring(
    bool graph[V][V], int m)
{
    // Initialize all color values as 0.
    // This initialization is needed
    // correct functioning of isSafe()
    int color[V];
    for (int i = 0; i < V; i++)
        color[i] = 0;
 
    // Call graphColoringUtil() for vertex 0
    if (
        graphColoringUtil(
            graph, m, color, 0)
        == false) {
        printf("Solution does not exist");
        return false;
    }
 
    // Print the solution
    printSolution(color);
    return true;
}
 
/* A utility function to print solution */
void printSolution(int color[])
{
    printf(
        "Solution Exists:"
        " Following are the assigned colors \n");
    for (int i = 0; i < V; i++)
        printf(" %d ", color[i]);
    printf("\n");
}
 
// driver program to test above function
int main()
{
    /* Create following graph and test 
       whether it is 3 colorable
      (3)---(2)
       |   / |
       |  /  |
       | /   |
      (0)---(1)
    */
    bool graph[V][V] = {
        { 0, 1, 1, 1 },
        { 1, 0, 1, 0 },
        { 1, 1, 0, 1 },
        { 1, 0, 1, 0 },
    };
    int m = 3; // Number of colors
    graphColoring(graph, m);
    return 0;
}

4. Rat in a Maze:-
  ------------------
  
#include <stdio.h> 
  
// Maze size 
#define N 4 
  
bool solveMazeUtil( 
    int maze[N][N], int x, 
    int y, int sol[N][N]); 
  
/* A utility function to print  
solution matrix sol[N][N] */
void printSolution(int sol[N][N]) 
{ 
    for (int i = 0; i < N; i++) { 
        for (int j = 0; j < N; j++) 
            printf(" %d ", sol[i][j]); 
        printf("\n"); 
    } 
} 
  
/* A utility function to check if x,  
y is valid index for N*N maze */
bool isSafe(int maze[N][N], int x, int y) 
{ 
    // if (x, y outside maze) return false 
    if ( 
        x >= 0 && x < N && y >= 0 
        && y < N && maze[x][y] == 1) 
        return true; 
  
    return false; 
} 
  
/* This function solves the Maze problem  
using Backtracking. It mainly uses  
solveMazeUtil() to solve the problem.  
It returns false if no path is possible,  
otherwise return true and prints the path  
in the form of 1s. Please note that there  
may be more than one solutions, this  
function prints one of the feasible  
solutions.*/
bool solveMaze(int maze[N][N]) 
{ 
    int sol[N][N] = { { 0, 0, 0, 0 }, 
                      { 0, 0, 0, 0 }, 
                      { 0, 0, 0, 0 }, 
                      { 0, 0, 0, 0 } }; 
  
    if (solveMazeUtil( 
            maze, 0, 0, sol) 
        == false) { 
        printf("Solution doesn't exist"); 
        return false; 
    } 
  
    printSolution(sol); 
    return true; 
} 
  
/* A recursive utility function  
to solve Maze problem */
bool solveMazeUtil( 
    int maze[N][N], int x, 
    int y, int sol[N][N]) 
{ 
    // if (x, y is goal) return true 
    if ( 
        x == N - 1 && y == N - 1 
        && maze[x][y] == 1) { 
        sol[x][y] = 1; 
        return true; 
    } 
  
    // Check if maze[x][y] is valid 
    if (isSafe(maze, x, y) == true) { 
        // mark x, y as part of solution path 
        sol[x][y] = 1; 
  
        /* Move forward in x direction */
        if (solveMazeUtil( 
                maze, x + 1, y, sol) 
            == true) 
            return true; 
  
        /* If moving in x direction 
           doesn't give solution then  
           Move down in y direction  */
        if (solveMazeUtil( 
                maze, x, y + 1, sol) 
            == true) 
            return true; 
  
        /* If none of the above movements  
           work then BACKTRACK: unmark  
           x, y as part of solution path */
        sol[x][y] = 0; 
        return false; 
    } 
  
    return false; 
} 
  
// driver program to test above function 
int main() 
{ 
    int maze[N][N] = { { 1, 0, 0, 0 }, 
                       { 1, 1, 0, 1 }, 
                       { 0, 1, 0, 0 }, 
                       { 1, 1, 1, 1 } }; 
  
    solveMaze(maze); 
    return 0; 
} 

5. Print all Permutations of a string/array:-
  ---------------------------------------------
  
void permute(string a, int l, int r)  
{  
    // Base case  
    if (l == r)  
        cout<<a<<endl;  
    else
    {  
        // Permutations made  
        for (int i = l; i <= r; i++)  
        {  
  
            // Swapping done  
            swap(a[l], a[i]);  
  
            // Recursion called  
            permute(a, l+1, r);  
  
            //backtrack  
            swap(a[l], a[i]);  
        }  
    }  
}  
  
// Driver Code  
int main()  
{  
    string str = "ABC";  
    int n = str.size();  
    permute(str, 0, n-1);  
    return 0;  
}  

6. Word Break (print all ways):-
  -------------------------------
  
  #include <iostream>
using namespace std;
 
/* A utility function to check whether a word
  is present in dictionary or not.  An array of
  strings is used for dictionary.  Using array
  of strings for dictionary is definitely not
  a good idea. We have used for simplicity of
  the program*/
int dictionaryContains(string &word)
{
    string dictionary[] = {"mobile","samsung","sam","sung",
                            "man","mango", "icecream","and",
                            "go","i","love","ice","cream"};
    int n = sizeof(dictionary)/sizeof(dictionary[0]);
    for (int i = 0; i < n; i++)
        if (dictionary[i].compare(word) == 0)
            return true;
    return false;
}
 
//prototype of wordBreakUtil
void wordBreakUtil(string str, int size, string result);
 
// Prints all possible word breaks of given string
void wordBreak(string str)
{
    // last argument is prefix
    wordBreakUtil(str, str.size(), "");
}
 
// result store the current prefix with spaces
// between words
void wordBreakUtil(string str, int n, string result)
{
    //Process all prefixes one by one
    for (int i=1; i<=n; i++)
    {
        //extract substring from 0 to i in prefix
        string prefix = str.substr(0, i);
 
        // if dictionary conatins this prefix, then
        // we check for remaining string. Otherwise
        // we ignore this prefix (there is no else for
        // this if) and try next
        if (dictionaryContains(prefix))
        {
            // if no more elements are there, print it
            if (i == n)
            {
                // add this element to previous prefix
                result += prefix;
                cout << result << endl; //print result
                return;
            }
            wordBreakUtil(str.substr(i, n-i), n-i,
                                result + prefix + " ");
        }
    }      //end for
}//end function
 
int main()
{
    cout << "First Test:\n";
    wordBreak("iloveicecreamandmango");
 
    cout << "\nSecond Test:\n";
    wordBreak("ilovesamsungmobile");
    return 0;
}

7. Combination sum-1 :-
  -----------------------

void findNumbers(vector<int>& ar, int sum, 
                 vector<vector<int> >& res, 
                 vector<int>& r, int i) 
{ 
    // If  current sum becomes negative 
    if (sum < 0) 
        return; 
  
    // if we get exact answer 
    if (sum == 0) 
    { 
        res.push_back(r); 
        return; 
    } 
  
    // Recur for all remaining elements that 
    // have value smaller than sum. 
    while (i < ar.size() && sum - ar[i] >= 0) 
    { 
  
        // Till every element in the array starting 
        // from i which can contribute to the sum 
        r.push_back(ar[i]); // add them to list 
  
        // recur for next numbers 
        findNumbers(ar, sum - ar[i], res, r, i); 
        i++; 
  
        // remove number from list (backtracking) 
        r.pop_back(); 
    } 
} 
  
// Returns all combinations of ar[] that have given 
// sum. 
vector<vector<int> > combinationSum(vector<int>& ar, 
                                            int sum) 
{ 
    // sort input array 
    sort(ar.begin(), ar.end()); 
  
    // remove duplicates 
    ar.erase(unique(ar.begin(), ar.end()), ar.end()); 
  
    vector<int> r; 
    vector<vector<int> > res; 
    findNumbers(ar, sum, res, r, 0); 
  
    return res; 
} 

8. Combination sum-2 :-
  ----------------------

 vector<vector<int> > combinationSum2(vector<int> &num, int target) 
    {
        vector<vector<int>> res;
        sort(num.begin(),num.end());
	num.erase(unique(num.begin(), num.end()), num.end()); 
        vector<int> local;
        findCombination(res, 0, target, local, num);
        return res;
    }
   
void findCombination(vector<vector<int>>& res, const int order, const int target, vector<int>& 								local, const vector<int>& num)
    {
        if(target==0)
        {
            res.push_back(local);
            return;
        }
        else
        {
            for(int i = order;i<num.size();i++) // iterative component
            {
                if(num[i]>target) return;
                local.push_back(num[i]),
                findCombination(res,i+1,target-num[i],local,num); // recursive componenet
                local.pop_back();
            }
        }
    }


9. Palindrome Partioning :-
  ----------------------------

void addStrings(vector<vector<string> > &v, string &s, 
                vector<string> &temp, int index) 
{ 
    int len = s.length(); 
    string str; 
    vector<string> current = temp; 
    if (index == 0) 
        temp.clear(); 
    for (int i = index; i < len; ++i) 
    { 
        str = str + s[i]; 
        if (checkPalindrome(str)) 
        { 
            temp.push_back(str); 
            if (i+1 < len) 
                addStrings(v,s,temp,i+1); 
            else
                v.push_back(temp); 
            temp = current; 
        } 
    } 
    return; 
} 
  
// Generates all palindromic partitions of 's' and 
// stores the result in 'v'. 
void partition(string s, vector<vector<string> >&v) 
{ 
    vector<string> temp; 
    addStrings(v, s, temp, 0); 
    return; 
} 
bool checkPalindrome(string str) 
{ 
    int len = str.length(); 
    len--; 
    for (int i=0; i<len; i++) 
    { 
        if (str[i] != str[len]) 
            return false; 
        len--; 
    } 
    return true; 
} 

10. Subset Sum-1 : -   //To be done with tuf placement series. This answer is not good.
   -------------------

#include <stdio.h> 
#include <stdlib.h> 
  
#define ARRAYSIZE(a) (sizeof(a))/(sizeof(a[0])) 
  
static int total_nodes; 
// prints subset found 
void printSubset(int A[], int size) 
{ 
    for(int i = 0; i < size; i++) 
    { 
        printf("%*d", 5, A[i]); 
    } 
  
    printf("n"); 
} 
  
// inputs 
// s            - set vector 
// t            - tuplet vector 
// s_size       - set size 
// t_size       - tuplet size so far 
// sum          - sum so far 
// ite          - nodes count 
// target_sum   - sum to be found 
void subset_sum(int s[], int t[], int s_size, int t_size,int sum, int ite,int const target_sum)                
{ 
    total_nodes++; 
    if( target_sum == sum ) 
    { 
        // We found subset 
        printSubset(t, t_size); 
        // Exclude previously added item and consider next candidate 
        subset_sum(s, t, s_size, t_size-1, sum - s[ite], ite + 1, target_sum); 
        return; 
    } 
    else
    { 
        // generate nodes along the breadth 
        for( int i = ite; i < s_size; i++ ) 
        { 
            t[t_size] = s[i]; 
            // consider next level node (along depth) 
            subset_sum(s, t, s_size, t_size + 1, sum + s[i], i + 1, target_sum); 
        } 
    } 
} 
  
// Wrapper to print subsets that sum to target_sum 
// input is weights vector and target_sum 
void generateSubsets(int s[], int size, int target_sum) 
{ 
    int *tuplet_vector = (int *)malloc(size * sizeof(int)); 
  
    subset_sum(s, tuplet_vector, size, 0, 0, 0, target_sum); 
  
    free(tuplet_vector); 
} 
  
int main() 
{ 
    int weights[] = {10, 7, 5, 18, 12, 20, 15}; 
    int size = ARRAYSIZE(weights); 
  
    generateSubsets(weights, size, 35); 
    printf("Nodes generated %dn", total_nodes); 
    return 0; 
} 

11. Subset Sum-2:-
   -----------------

//To be done with tuf placement series.

12. K-th permutation Sequence : -
   --------------------------------

string getPermutation(int n, int k) {
        string a = "";
        for (int i = 1; i <= n; i++)
            a += to_string(i);
        vector<int> fact(n + 1);
        fact[0] = 1;
        for (int i = 1; i <= n; i++)
            fact[i] = fact[i - 1] * i;
        k--;
        string ans = "";
        for (int i = n - 1; i >= 0; i--) {
            int index = k / fact[i];
            k %= fact[i];
            ans += a[index];
            a.erase(a.begin() + index);
        }
        return ans;
    }


==> Divide and Conquer :-
   ------------------------

1. 1/N-th root of an integer (use binary search) (square root, cube root, ..) :-
  ---------------------------------------------------------------------------------

#include<bits/stdc++.h> 
using namespace std; 
  
void findNthRoot(double x, int n) 
{ //n can be any value 2 for suare root, 3 for cube root and so on....
  
// Initialize boundary values  
double low, high; 
if (x >= 0 and x <= 1) 
{ 
    low = x; 
    high = 1; 
} 
else
{ 
    low = 1; 
    high = x;  
}  
  
// used for taking approximations  
// of the answer  
double epsilon = 0.00000001; 
  
// Do binary search  
double guess = (low + high) / 2; 
while (abs((pow(guess, n)) - x) >= epsilon) 
{ 
    if (pow(guess, n) > x) 
    { 
        high = guess ; 
    }  
    else
    { 
        low = guess ; 
    } 
    guess = (low + high) / 2; 
} 
  
cout << fixed << setprecision(16)  
     << guess; 
}      
  
// Driver code  
int main() 
{ 
    double x = 5; 
    int n = 2; 
    findNthRoot(x, n) ; 
}

2. Matrix Median : -
  ---------------------

const int MAX = 100; 
  
// function to find median in the matrix 
int binaryMedian(int m[][MAX], int r ,int c) 
{ 
    int min = INT_MAX, max = INT_MIN; 
    for (int i=0; i<r; i++) 
    { 
        // Finding the minimum element 
        if (m[i][0] < min) 
            min = m[i][0]; 
  
        // Finding the maximum element 
        if (m[i][c-1] > max) 
            max = m[i][c-1]; 
    } 
  
    int desired = (r * c + 1) / 2; 
    while (min < max) 
    { 
        int mid = min + (max - min) / 2; 
        int place = 0; 
  
        // Find count of elements smaller than mid 
        for (int i = 0; i < r; ++i) 
            place += upper_bound(m[i], m[i]+c, mid) - m[i]; 
        if (place < desired) 
            min = mid + 1; 
        else
            max = mid; 
    } 
    return min; 
} 

3. Find the element that appears once in sorted array, and rest element appears twice
	(Binary search) : -
------------------------------------------------------------------------------------------

void search(int arr[], int low, int high)
{
 
    // Base cases
    if (low > high)
        return;
 
    if (low == high) {
        cout << "The required element is " << arr[low];
        return;
    }
 
    // Find the middle point
    int mid = (low + high) / 2;
 
    // If mid is even and element next to mid is
    // same as mid, then output element lies on
    // right side, else on left side
    if (mid % 2 == 0) {
        if (arr[mid] == arr[mid + 1])
            search(arr, mid + 2, high);
        else
            search(arr, low, mid);
    }
 
    // If mid is odd
    else {
        if (arr[mid] == arr[mid - 1])
            search(arr, mid + 1, high);
        else
            search(arr, low, mid - 1);
    }
}

4. Search element in a sorted and rotated array/ find pivot where it is rotated :-
  ---------------------------------------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
// Returns index of key in arr[l..h] if 
// key is present, otherwise returns -1 
int search(int arr[], int l, int h, int key) 
{ 
    if (l > h) 
        return -1; 
  
    int mid = (l + h) / 2; 
    if (arr[mid] == key) 
        return mid; 
  
    /* If arr[l...mid] is sorted */
    if (arr[l] <= arr[mid]) { 
        /* As this subarray is sorted, we can quickly 
        check if key lies in half or other half */
        if (key >= arr[l] && key <= arr[mid]) 
            return search(arr, l, mid - 1, key); 
        /*If key not lies in first half subarray,  
           Divide other half  into two subarrays, 
           such that we can quickly check if key lies  
           in other half */
        return search(arr, mid + 1, h, key); 
    } 
  
    /* If arr[l..mid] first subarray is not sorted, then arr[mid... h] 
    must be sorted subarray */
    if (key >= arr[mid] && key <= arr[h]) 
        return search(arr, mid + 1, h, key); 
  
    return search(arr, l, mid - 1, key); 
} 

5. Median of 2 sorted arrays : -
  -----------------------------

#include <bits/stdc++.h>
using namespace std;
 
// A utility function to find median of two integers
float MO2(int a, int b)
{ return ( a + b ) / 2.0; }
 
// A utility function to find median of three integers
float MO3(int a, int b, int c)
{
    return a + b + c - max(a, max(b, c))
                     - min(a, min(b, c));
}
 
// A utility function to find a median of four integers
float MO4(int a, int b, int c, int d)
{
    int Max = max( a, max( b, max( c, d ) ) );
    int Min = min( a, min( b, min( c, d ) ) );
    return ( a + b + c + d - Max - Min ) / 2.0;
}
 
// Utility function to find median of single array
float medianSingle(int arr[], int n)
{
   if (n == 0)
      return -1;
   if (n%2 == 0)
        return (double)(arr[n/2] + arr[n/2-1])/2;
   return arr[n/2];
}
 
// This function assumes that N is smaller than or equal to M
// This function returns -1 if both arrays are empty
float findMedianUtil( int A[], int N, int B[], int M )
{
    // If smaller array is empty, return median from second array
    if (N == 0)
      return medianSingle(B, M);
 
    // If the smaller array has only one element
    if (N == 1)
    {
        // Case 1: If the larger array also has one element,
        // simply call MO2()
        if (M == 1)
            return MO2(A[0], B[0]);
 
        // Case 2: If the larger array has odd number of elements,
        // then consider the middle 3 elements of larger array and
        // the only element of smaller array. Take few examples
        // like following
        // A = {9}, B[] = {5, 8, 10, 20, 30} and
        // A[] = {1}, B[] = {5, 8, 10, 20, 30}
        if (M & 1)
            return MO2( B[M/2], MO3(A[0], B[M/2 - 1], B[M/2 + 1]) );
 
        // Case 3: If the larger array has even number of element,
        // then median will be one of the following 3 elements
        // ... The middle two elements of larger array
        // ... The only element of smaller array
        return MO3( B[M/2], B[M/2 - 1], A[0] );
    }
 
    // If the smaller array has two elements
    else if (N == 2)
    {
        // Case 4: If the larger array also has two elements,
        // simply call MO4()
        if (M == 2)
            return MO4(A[0], A[1], B[0], B[1]);
 
        // Case 5: If the larger array has odd number of elements,
        // then median will be one of the following 3 elements
        // 1. Middle element of larger array
        // 2. Max of first element of smaller array and element
        //    just before the middle in bigger array
        // 3. Min of second element of smaller array and element
        //    just after the middle in bigger array
        if (M & 1)
            return MO3 ( B[M/2],
                         max(A[0], B[M/2 - 1]),
                         min(A[1], B[M/2 + 1])
                       );
 
        // Case 6: If the larger array has even number of elements,
        // then median will be one of the following 4 elements
        // 1) & 2) The middle two elements of larger array
        // 3) Max of first element of smaller array and element
        //    just before the first middle element in bigger array
        // 4. Min of second element of smaller array and element
        //    just after the second middle in bigger array
        return MO4 ( B[M/2],
                     B[M/2 - 1],
                     max( A[0], B[M/2 - 2] ),
                     min( A[1], B[M/2 + 1] )
                   );
    }
 
    int idxA = ( N - 1 ) / 2;
    int idxB = ( M - 1 ) / 2;
 
     /* if A[idxA] <= B[idxB], then median must exist in
        A[idxA....] and B[....idxB] */
    if (A[idxA] <= B[idxB] )
      return findMedianUtil(A + idxA, N/2 + 1, B, M - idxA );
 
    /* if A[idxA] > B[idxB], then median must exist in
       A[...idxA] and B[idxB....] */
    return findMedianUtil(A, N/2 + 1, B + idxA, M - idxA );
}
 
// A wrapper function around findMedianUtil(). This function
// makes sure that smaller array is passed as first argument
// to findMedianUtil
float findMedian( int A[], int N, int B[], int M )
{
    if (N > M)
       return findMedianUtil( B, M, A, N );
 
    return findMedianUtil( A, N, B, M );
}
 
// Driver program to test above functions
int main()
{
    int A[] = {900};
    int B[] = {5, 8, 10, 20};
 
    int N = sizeof(A) / sizeof(A[0]);
    int M = sizeof(B) / sizeof(B[0]);
 
    printf("%f", findMedian( A, N, B, M ) );
    return 0;
}

6. K-th element of two sorted arrays :-
  ________________________________________

#include <iostream>
using namespace std;
 
int kth(int arr1[], int m, int arr2[], int n, int k)
{
     
  if (k > (m+n) || k < 1) return -1;
   
  // let m <= n
  if (m > n) return kth(arr2, n, arr1, m, k);
   
  // if arr1 is empty returning k-th element of arr2
  if (m == 0) return arr2[k - 1];
   
  // if k = 1 return minimum of first two elements of both arrays 
  if (k == 1) return min(arr1[0], arr2[0]);
   
  // now the divide and conquer part
  int i = min(m, k / 2), j = min(n, k / 2);
   
  if (arr1[i - 1] > arr2[j - 1] ) 
    // Now we need to find only k-j th element since we have found out the lowest j
    return kth(arr1, m, arr2 + j, n - j, k - j);
  else
    // Now we need to find only k-i th element since we have found out the lowest i
    return kth(arr1 + i, m - i, arr2, n, k - i);
}
 
// Driver code
int main()
{
    int arr1[5] = {2, 3, 6, 7, 9};
    int arr2[4] = {1, 4, 8, 10};
    int m = sizeof(arr1)/sizeof(arr1[0]);
    int n = sizeof(arr2)/sizeof(arr2[0]);
    int k = 5;
     
    int ans = kth(arr1,m,arr2, n, k);
     
    if(ans == -1) cout<<"Invalid query";
    else cout<<ans;
     
    return 0;
}

=> Stack and Queue :-
  ----------------------

1. Implement Stack :-
  ----------------------------------------

#define MAX 1000
 
class Stack {
    int top;
 
public:
    int a[MAX]; // Maximum size of Stack
 
    Stack() { top = -1; }
    bool push(int x);
    int pop();
    int peek();
    bool isEmpty();
};
 
bool Stack::push(int x)
{
    if (top >= (MAX - 1)) {
        cout << "Stack Overflow";
        return false;
    }
    else {
        a[++top] = x;
        cout << x << " pushed into stack\n";
        return true;
    }
}
 
int Stack::pop()
{
    if (top < 0) {
        cout << "Stack Underflow";
        return 0;
    }
    else {
        int x = a[top--];
        return x;
    }
}
int Stack::peek()
{
    if (top < 0) {
        cout << "Stack is Empty";
        return 0;
    }
    else {
        int x = a[top];
        return x;
    }
}
 
bool Stack::isEmpty()
{
    return (top < 0);
}

2. Implement Queue :-
  ---------------------

#define SIZE 10

class Queue
{
    int a[SIZE];
    int rear;   //same as tail
    int front;  //same as head
  
    public:
    Queue()
    {
        rear = front = -1;
    }
    
    //declaring enqueue, dequeue and display functions
    void enqueue(int x);     
    int dequeue();
    void display();
};

// function enqueue - to add data to queue
void Queue :: enqueue(int x)
{
    if(front == -1) {
        front++;
    }
    if( rear == SIZE-1)
    {
        cout << "Queue is full";
    }
    else
    {
        a[++rear] = x;
    }
}

// function dequeue - to remove data from queue
int Queue :: dequeue()
{
    return a[++front];  // following approach [B], explained above
}

// function to display the queue elements
void Queue :: display()
{
    int i;
    for( i = front; i <= rear; i++)
    {
        cout << a[i] << endl;
    }
}

3. Implement Stack using Queue :-
  ---------------------------------
class Stack { 
    // Two inbuilt queues 
    queue<int> q1, q2; 
  
    // To maintain current number of 
    // elements 
    int curr_size; 
  
public: 
    Stack() 
    { 
        curr_size = 0; 
    } 
  
    void push(int x) 
    { 
        curr_size++; 
  
        // Push x first in empty q2 
        q2.push(x); 
  
        // Push all the remaining 
        // elements in q1 to q2. 
        while (!q1.empty()) { 
            q2.push(q1.front()); 
            q1.pop(); 
        } 
  
        // swap the names of two queues 
        queue<int> q = q1; 
        q1 = q2; 
        q2 = q; 
    } 
  
    void pop() 
    { 
  
        // if no elements are there in q1 
        if (q1.empty()) 
            return; 
        q1.pop(); 
        curr_size--; 
    } 
  
    int top() 
    { 
        if (q1.empty()) 
            return -1; 
        return q1.front(); 
    } 
  
    int size() 
    { 
        return curr_size; 
    } 
}; 

4. Implement Queue using Stack :-
  ---------------------------------

struct Queue { 
    stack<int> s1, s2; 
  
    // Enqueue an item to the queue 
    void enQueue(int x) 
    { 
        // Push item into the first stack 
        s1.push(x); 
    } 
  
    // Dequeue an item from the queue 
    int deQueue() 
    { 
        // if both stacks are empty 
        if (s1.empty() && s2.empty()) { 
            cout << "Q is empty"; 
            exit(0); 
        } 
  
        // if s2 is empty, move 
        // elements from s1 
        if (s2.empty()) { 
            while (!s1.empty()) { 
                s2.push(s1.top()); 
                s1.pop(); 
            } 
        } 
        // return the top item from s2 
        int x = s2.top(); 
        s2.pop(); 
        return x; 
    } 
}; 

5. Check for balanced parentheses :-
  -----------------------------------


#include <bits/stdc++.h> 
using namespace std; 
  
// function to check if brackets are balanced 
bool areBracketsBalanced(string expr) 
{   
    stack<char> s; 
    char x; 
  
    // Traversing the Expression 
    for (int i = 0; i < expr.length(); i++)  
    { 
        if (expr[i] == '(' || expr[i] == '['
            || expr[i] == '{')  
        { 
            // Push the element in the stack 
            s.push(expr[i]); 
            continue; 
        } 
  
        // IF current current character is not opening 
        // bracket, then it must be closing. So stack 
        // cannot be empty at this point. 
        if (s.empty()) 
            return false; 
  
        switch (expr[i]) { 
        case ')': 
              
            // Store the top element in a 
            x = s.top(); 
            s.pop(); 
            if (x == '{' || x == '[') 
                return false; 
            break; 
  
        case '}': 
  
            // Store the top element in b 
            x = s.top(); 
            s.pop(); 
            if (x == '(' || x == '[') 
                return false; 
            break; 
  
        case ']': 
  
            // Store the top element in c 
            x = s.top(); 
            s.pop(); 
            if (x == '(' || x == '{') 
                return false; 
            break; 
        } 
    } 
  
    // Check Empty Stack 
    return (s.empty()); 
} 
  
// Driver code 
int main() 
{ 
    string expr = "{()}[]"; 
  
    // Function call 
    if (areBracketsBalanced(expr)) 
        cout << "Balanced"; 
    else
        cout << "Not Balanced"; 
    return 0; 
} 

6. Next Greater Element : -
  ---------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
/* prints element and NGE pair for all 
elements of arr[] of size n */
void printNGE(int arr[], int n) { 
  stack < int > s; 
  
  /* push the first element to stack */
  s.push(arr[0]); 
  
  // iterate for rest of the elements 
  for (int i = 1; i < n; i++) { 
  
    if (s.empty()) { 
      s.push(arr[i]); 
      continue; 
    } 
  
    /* if stack is not empty, then 
       pop an element from stack. 
       If the popped element is smaller 
       than next, then 
    a) print the pair 
    b) keep popping while elements are 
    smaller and stack is not empty */
    while (s.empty() == false && s.top() < arr[i]) 
    {          
        cout << s.top() << " --> " << arr[i] << endl; 
        s.pop(); 
    } 
  
    /* push next to stack so that we can find 
    next greater for it */
    s.push(arr[i]); 
  } 
  
  /* After iterating over the loop, the remaining 
  elements in stack do not have the next greater 
  element, so print -1 for them */
  while (s.empty() == false) { 
    cout << s.top() << " --> " << -1 << endl; 
    s.pop(); 
  } 
} 
  
/* Driver program to test above functions */
int main() { 
  int arr[] = {11, 13, 21, 3}; 
  int n = sizeof(arr) / sizeof(arr[0]); 
  printNGE(arr, n); 
  return 0; 
}

Day14 :-
---------

1. Next Smaller Element :-
  ---------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
/* prints element and NSE pair for all 
elements of arr[] of size n */
void printNSE(int arr[], int n) 
{ 
    stack<int> s; 
    unordered_map<int, int> mp; 
  
    /* push the first element to stack */
    s.push(arr[0]); 
      
  
    // iterate for rest of the elements 
    for (int i = 1; i < n; i++) { 
  
        if (s.empty()) { 
            s.push(arr[i]); 
            continue; 
        } 
  
        /* if stack is not empty, then 
       pop an element from stack. 
       If the popped element is smaller 
       than next, then 
    a) print the pair 
    b) keep popping while elements are 
    smaller and stack is not empty */
        while (s.empty() == false && s.top() > arr[i]) { 
            mp[s.top()] = arr[i]; 
            s.pop(); 
        } 
  
        /* push next to stack so that we can find 
    next smaller for it */
        s.push(arr[i]); 
    } 
  
    /* After iterating over the loop, the remaining 
  elements in stack do not have the next smaller 
  element, so print -1 for them */
    while (s.empty() == false) { 
         mp[s.top()] = -1; 
        s.pop(); 
    } 
  
    for (int i=0; i<n; i++) 
       cout << arr[i] << " ---> " << mp[arr[i]] << endl; 
} 
  
/* Driver program to test above functions */
int main() 
{ 
    int arr[] = { 11, 13, 21, 3 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    printNSE(arr, n); 
    return 0; 
}

2. LRU cache (vvvv. imp) :-
  --------------------------

#include <bits/stdc++.h>
using namespace std;
 
class LRUCache {
    // store keys of cache
    list<int> dq;
 
    // store references of key in cache
    unordered_map<int, list<int>::iterator> ma;
    int csize; // maximum capacity of cache
 
public:
    LRUCache(int);
    void refer(int);
    void display();
};
 
// Declare the size
LRUCache::LRUCache(int n)
{
    csize = n;
}
 
// Refers key x with in the LRU cache
void LRUCache::refer(int x)
{
    // not present in cache
    if (ma.find(x) == ma.end()) {
        // cache is full
        if (dq.size() == csize) {
            // delete least recently used element
            int last = dq.back();
 
            // Pops the last elmeent
            dq.pop_back();
 
            // Erase the last
            ma.erase(last);
        }
    }
 
    // present in cache
    else
        dq.erase(ma[x]);
 
    // update reference
    dq.push_front(x);
    ma[x] = dq.begin();
}
 
// Function to display contents of cache
void LRUCache::display()
{
 
    // Iterate in the deque and print
    // all the elements in it
    for (auto it = dq.begin(); it != dq.end();
         it++)
        cout << (*it) << " ";
 
    cout << endl;
}
 
// Driver Code
int main()
{
    LRUCache ca(4);
 
    ca.refer(1);
    ca.refer(2);
    ca.refer(3);
    ca.refer(1);
    ca.refer(4);
    ca.refer(5);
    ca.display();
 
    return 0;
}

3. Largest rectangle in histogram :-
  ------------------------------------

int getMaxArea(int hist[], int n) 
{ 
    // Create an empty stack. The stack holds indexes  
    // of hist[] array. The bars stored in stack are  
    // always in increasing order of their heights. 
    stack<int> s; 
  
    int max_area = 0; // Initialize max area 
    int tp;  // To store top of stack 
    int area_with_top; // To store area with top bar 
                       // as the smallest bar 
  
    // Run through all bars of given histogram 
    int i = 0; 
    while (i < n) 
    { 
        // If this bar is higher than the bar on top  
        // stack, push it to stack 
        if (s.empty() || hist[s.top()] <= hist[i]) 
            s.push(i++); 
  
        // If this bar is lower than top of stack,  
        // then calculate area of rectangle with stack  
        // top as the smallest (or minimum height) bar.  
        // 'i' is 'right index' for the top and element  
        // before top in stack is 'left index' 
        else
        { 
            tp = s.top();  // store the top index 
            s.pop();  // pop the top 
  
            // Calculate the area with hist[tp] stack  
            // as smallest bar 
            area_with_top = hist[tp] * (s.empty() ? i :  
                                   i - s.top() - 1); 
  
            // update max area, if needed 
            if (max_area < area_with_top) 
                max_area = area_with_top; 
        } 
    } 
  
    // Now pop the remaining bars from stack and calculate 
    // area with every popped bar as the smallest bar 
    while (s.empty() == false) 
    { 
        tp = s.top(); 
        s.pop(); 
        area_with_top = hist[tp] * (s.empty() ? i :  
                                i - s.top() - 1); 
  
        if (max_area < area_with_top) 
            max_area = area_with_top; 
    } 
  
    return max_area; 
} 
  
// Driver program to test above function 
int main() 
{ 
    int hist[] = {6, 2, 5, 4, 5, 1, 6}; 
    int n = sizeof(hist)/sizeof(hist[0]); 
    cout << "Maximum area is " << getMaxArea(hist, n); 
    return 0; 
}

4. Sliding Window maximum :-
  ----------------------------

#include <bits/stdc++.h>
using namespace std;
 
// A Dequeue (Double ended queue) based 
// method for printing maximum element of
// all subarrays of size k
void printKMax(int arr[], int n, int k)
{
     
    // Create a Double Ended Queue, 
    // Qi that will store indexes 
    // of array elements
    // The queue will store indexes 
    // of useful elements in every 
    // window and it will
    // maintain decreasing order of 
    // values from front to rear in Qi, i.e.,
    // arr[Qi.front[]] to arr[Qi.rear()] 
    // are sorted in decreasing order
    std::deque<int> Qi(k);
 
    /* Process first k (or first window) 
     elements of array */
    int i;
    for (i = 0; i < k; ++i) 
    {
     
        // For every element, the previous
        // smaller elements are useless so
        // remove them from Qi
        while ((!Qi.empty()) && arr[i] >= 
                            arr[Qi.back()])
           
             // Remove from rear
            Qi.pop_back();
 
        // Add new element at rear of queue
        Qi.push_back(i);
    }
 
    // Process rest of the elements, 
    // i.e., from arr[k] to arr[n-1]
    for (; i < n; ++i) 
    {
     
        // The element at the front of 
        // the queue is the largest element of
        // previous window, so print it
        cout << arr[Qi.front()] << " ";
 
        // Remove the elements which 
        // are out of this window
        while ((!Qi.empty()) && Qi.front() <= 
                                           i - k)
           
            // Remove from front of queue
            Qi.pop_front(); 
 
        // Remove all elements 
        // smaller than the currently
        // being added element (remove 
        // useless elements)
        while ((!Qi.empty()) && arr[i] >= 
                             arr[Qi.back()])
            Qi.pop_back();
 
        // Add current element at the rear of Qi
        Qi.push_back(i);
    }
 
    // Print the maximum element 
    // of last window
    cout << arr[Qi.front()];
}
 
// Driver code
int main()
{
    int arr[] = { 12, 1, 78, 90, 57, 89, 56 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 3;
    printKMax(arr, n, k);
    return 0;
}

5. Implement Min Stack :-
  -------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
// A user defined stack that supports getMin() in 
// addition to push() and pop() 
struct MyStack 
{ 
    stack<int> s; 
    int minEle; 
  
    // Prints minimum element of MyStack 
    void getMin() 
    { 
        if (s.empty()) 
            cout << "Stack is empty\n"; 
  
        // variable minEle stores the minimum element 
        // in the stack. 
        else
            cout <<"Minimum Element in the stack is: "
                 << minEle << "\n"; 
    } 
  
    // Prints top element of MyStack 
    void peek() 
    { 
        if (s.empty()) 
        { 
            cout << "Stack is empty "; 
            return; 
        } 
  
        int t = s.top(); // Top element. 
  
        cout << "Top Most Element is: "; 
  
        // If t < minEle means minEle stores 
        // value of t. 
        (t < minEle)? cout << minEle: cout << t; 
    } 
  
    // Remove the top element from MyStack 
    void pop() 
    { 
        if (s.empty()) 
        { 
            cout << "Stack is empty\n"; 
            return; 
        } 
  
        cout << "Top Most Element Removed: "; 
        int t = s.top(); 
        s.pop(); 
  
        // Minimum will change as the minimum element 
        // of the stack is being removed. 
        if (t < minEle) 
        { 
            cout << minEle << "\n"; 
            minEle = 2*minEle - t; 
        } 
  
        else
            cout << t << "\n"; 
    } 
  
    // Removes top element from MyStack 
    void push(int x) 
    { 
        // Insert new number into the stack 
        if (s.empty()) 
        { 
            minEle = x; 
            s.push(x); 
            cout <<  "Number Inserted: " << x << "\n"; 
            return; 
        } 
  
        // If new number is less than minEle 
        if (x < minEle) 
        { 
            s.push(2*x - minEle); 
            minEle = x; 
        } 
  
        else
           s.push(x); 
  
        cout <<  "Number Inserted: " << x << "\n"; 
    } 
}; 
  
// Driver Code 
int main() 
{ 
    MyStack s; 
    s.push(3); 
    s.push(5); 
    s.getMin(); 
    s.push(2); 
    s.push(1); 
    s.getMin(); 
    s.pop(); 
    s.getMin(); 
    s.pop(); 
    s.peek(); 
  
    return 0; 
} 

6. Rotten Orange (Using BFS) :-
  ------------------------------

#include<bits/stdc++.h>
#define R 3
#define C 5
using namespace std;
 
// function to check whether a cell is valid / invalid
bool isvalid(int i, int j)
{
    return (i >= 0 && j >= 0 && i < R && j < C);
}
 
// structure for storing coordinates of the cell
struct ele {
    int x, y;
};
 
// Function to check whether the cell is delimiter
// which is (-1, -1)
bool isdelim(ele temp)
{
    return (temp.x == -1 && temp.y == -1);
}
 
// Function to check whether there is still a fresh
// orange remaining
bool checkall(int arr[][C])
{
    for (int i=0; i<R; i++)
       for (int j=0; j<C; j++)
          if (arr[i][j] == 1)
             return true;
    return false;
}
 
// This function finds if it is possible to rot all oranges or not.
// If possible, then it returns minimum time required to rot all,
// otherwise returns -1
int rotOranges(int arr[][C])
{
    // Create a queue of cells
    queue<ele> Q;
    ele temp;
    int ans = 0;
 
    // Store all the cells having rotten orange in first time frame
    for (int i=0; i<R; i++)
    {
       for (int j=0; j<C; j++)
       {
            if (arr[i][j] == 2)
            {
                temp.x = i;
                temp.y = j;
                Q.push(temp);
            }
        }
    }
 
    // Separate these rotten oranges from the oranges which will rotten
    // due the oranges in first time frame using delimiter which is (-1, -1)
    temp.x = -1;
    temp.y = -1;
    Q.push(temp);
 
    // Process the grid while there are rotten oranges in the Queue
    while (!Q.empty())
    {
        // This flag is used to determine whether even a single fresh
        // orange gets rotten due to rotten oranges in current time
        // frame so we can increase the count of the required time.
        bool flag = false;
 
        // Process all the rotten oranges in current time frame.
        while (!isdelim(Q.front()))
        {
            temp = Q.front();
 
            // Check right adjacent cell that if it can be rotten
            if (isvalid(temp.x+1, temp.y) && arr[temp.x+1][temp.y] == 1)
            {
                // if this is the first orange to get rotten, increase
                // count and set the flag.
                if (!flag) ans++, flag = true;
 
                // Make the orange rotten
                arr[temp.x+1][temp.y] = 2;
 
                // push the adjacent orange to Queue
                temp.x++;
                Q.push(temp);
 
                temp.x--; // Move back to current cell
            }
 
            // Check left adjacent cell that if it can be rotten
            if (isvalid(temp.x-1, temp.y) && arr[temp.x-1][temp.y] == 1) {
                if (!flag) ans++, flag = true;
                arr[temp.x-1][temp.y] = 2;
                temp.x--;
                Q.push(temp); // push this cell to Queue
                temp.x++;
            }
 
            // Check top adjacent cell that if it can be rotten
            if (isvalid(temp.x, temp.y+1) && arr[temp.x][temp.y+1] == 1) {
                if (!flag) ans++, flag = true;
                arr[temp.x][temp.y+1] = 2;
                temp.y++;
                Q.push(temp); // Push this cell to Queue
                temp.y--;
            }
 
            // Check bottom adjacent cell if it can be rotten
            if (isvalid(temp.x, temp.y-1) && arr[temp.x][temp.y-1] == 1) {
                if (!flag) ans++, flag = true;
                arr[temp.x][temp.y-1] = 2;
                temp.y--;
                Q.push(temp); // push this cell to Queue
            }
 
            Q.pop();
        }
 
        // Pop the delimiter
        Q.pop();
 
        // If oranges were rotten in current frame than separate the
        // rotten oranges using delimiter for the next frame for processing.
        if (!Q.empty()) {
            temp.x = -1;
            temp.y = -1;
            Q.push(temp);
        }
 
        // If Queue was empty than no rotten oranges left to process so exit
    }
 
    // Return -1 if all arranges could not rot, otherwise return ans.
    return (checkall(arr))? -1: ans;
}
 
// Driver program
int main()
{
    int arr[][C] = { {2, 1, 0, 2, 1},
                     {1, 0, 1, 2, 1},
                     {1, 0, 0, 2, 1}};
    int ans = rotOranges(arr);
    if (ans == -1)
        cout << "All oranges cannot rotn";
    else
         cout << "Time required for all oranges to rot => " << ans << endl;
    return 0;
}

Day15: (String)
----------------

1. Reverse Words in a String :-
  -------------------------------

class GFG{
     
// Reverse the string
public static String[] RevString(String[] s,
                                 int l)
{
     
    // Check if number of words is even
    if (l % 2 == 0)
    {
         
        // Find the middle word
        int j = l / 2;
         
        // Starting from the middle
        // start swapping words at 
        // jth position and l-1-j position
        while (j <= l - 1)
        {
            String temp;
            temp = s[l - j - 1];
            s[l - j - 1] = s[j];
            s[j] = temp;
            j += 1;
        }
    }
     
    // Check if number of words is odd
    else
    {
         
        // Find the middle word
        int j = (l / 2) + 1;
         
        // Starting from the middle start
        // swapping the words at jth 
        // position and l-1-j position
        while (j <= l - 1) 
        {
            String temp;
            temp = s[l - j - 1];
            s[l - j - 1] = s[j];
            s[j] = temp;
            j += 1;
        }
    }
     
    // Return the reversed sentence
    return s;
}
 
// Driver Code
public static void main(String[] args)
{
    String s = "getting good at coding " + 
               "needs a lot of practice";
    String[] words = s.split("\\s");
     
    words = RevString(words, words.length);
     
    s = String.join(" ", words);
     
    System.out.println(s);
}
}

2. Longest Palindrome in a string :-
  ------------------------------------

public String longestPalindrome(String s)
{
	if(s==NULL || s.length()<1) 
		return "" ;
	int start =0, end=0;
	for(int i=0;i<s.length();i++)
	{
		int len1=expandFromMiddle(s,i,i);
		int len2=expandFromMiddle(s,i,i+1);
		int len=Math.max(len1,len2);
		if(len>end-start){
			start=i-((len-1)/2);
			end=i+(len/2);
		}
	}
	return s.substring(start,end+1);
}

public int expandFromMiddle(String s, int left, int right)
{
	if(s==null || left>right)
		return 0;
	while(left>=0 && right<s.length() && s.charAt(left)==s.charAt(right))
	{
		left--;
		right++;
	}
	return right-left-1;
}

3. Roman Number to Integer and vice versa :-
  --------------------------------------------

 (i)  // Function to convert decimal to Roman Numerals

#include <bits/stdc++.h>
using namespace std;
 

int printRoman(int number)
{
    int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};
    string sym[] = {"I","IV","V","IX","X","XL","L","XC","C","CD","D","CM","M"};
    int i=12;    
    while(number>0)
    {
      int div = number/num[i];
      number = number%num[i];
      while(div--)
      {
        cout<<sym[i];
      }
      i--;
    }
}
 
//Driver program
int main()
{
    int number = 3549;
 
    printRoman(number);
 
    return 0;
}

(ii) // Program to convert Roman Numerals to Numbers

#include <bits/stdc++.h>
using namespace std;
 
// This function returns value
// of a Roman symbol
int value(char r)
{
    if (r == 'I')
        return 1;
    if (r == 'V')
        return 5;
    if (r == 'X')
        return 10;
    if (r == 'L')
        return 50;
    if (r == 'C')
        return 100;
    if (r == 'D')
        return 500;
    if (r == 'M')
        return 1000;
 
    return -1;
}
 
// Returns decimal value of
// roman numaral
int romanToDecimal(string& str)
{
    // Initialize result
    int res = 0;
 
    // Traverse given input
    for (int i = 0; i < str.length(); i++) 
    {
        // Getting value of symbol s[i]
        int s1 = value(str[i]);
 
        if (i + 1 < str.length()) 
        {
            // Getting value of symbol s[i+1]
            int s2 = value(str[i + 1]);
 
            // Comparing both values
            if (s1 >= s2) 
            {
                // Value of current symbol
                // is greater or equal to
                // the next symbol
                res = res + s1;  // LX= valueof L(50) +Valueof X(10) i.e 60
            }
            else
            {
                // Value of current symbol is
                // less than the next symbol
                res = res + s2 - s1;  // In IX valueof(I) <Valueof(X) so we do X(10)-I(1) i.e 9
                i++;
            }
        }
        else {
            res = res + s1;
        }
    }
    return res;
}
 
// Driver Code
int main()
{
    // Considering inputs given are valid
    string str = "MCMIV";
    cout << "Integer form of Roman Numeral is "
         << romanToDecimal(str) << endl;
 
    return 0;
}

4. Implement ATOI/STRSTR :-
  ---------------------------

#include <bits/stdc++.h>
 
using namespace std;
int myAtoi(const char* str)
{
    int sign = 1, base = 0, i = 0;
     
    // if whitespaces then ignore.
    while (str[i] == ' ') 
    {
        i++;
    }
     
    // sign of number
    if (str[i] == '-' || str[i] == '+') 
    {
        sign = 1 - 2 * (str[i++] == '-');
    }
   
    // checking for valid input
    while (str[i] >= '0' && str[i] <= '9') 
    {
        // handling overflow test case
        if (base > INT_MAX / 10
            || (base == INT_MAX / 10 
            && str[i] - '0' > 7)) 
        {
            if (sign == 1)
                return INT_MAX;
            else
                return INT_MIN;
        }
        base = 10 * base + (str[i++] - '0');
    }
    return base * sign;
}
 
 
// Driver Code
int main()
{
    char str[] = "  -123";
   
    // Functional Code
    int val = myAtoi(str);
    printf("%d ", val);
    return 0;
}

5. Longest Common Prefix :-
  --------------------------

#include<bits/stdc++.h> 
using namespace std; 
  
// A Utility Function to find the common prefix between 
// strings- str1 and str2 
string commonPrefixUtil(string str1, string str2) 
{ 
    string result; 
    int n1 = str1.length(), n2 = str2.length(); 
  
    for (int i=0, j=0; i<=n1-1&&j<=n2-1; i++,j++) 
    { 
        if (str1[i] != str2[j]) 
            break; 
        result.push_back(str1[i]); 
    } 
    return (result); 
} 
  
// A Divide and Conquer based function to find the 
// longest common prefix. This is similar to the 
// merge sort technique 
string commonPrefix(string arr[], int low, int high) 
{ 
    if (low == high) 
        return (arr[low]); 
  
    if (high > low) 
    { 
        // Same as (low + high)/2, but avoids overflow for 
        // large low and high 
        int mid = low + (high - low) / 2; 
  
        string str1 = commonPrefix(arr, low, mid); 
        string str2 = commonPrefix(arr, mid+1, high); 
  
        return (commonPrefixUtil(str1, str2)); 
    } 
} 
  
// Driver program to test above function 
int main() 
{ 
    string arr[] = {"geeksforgeeks", "geeks", 
                    "geek", "geezer"}; 
    int n = sizeof (arr) / sizeof (arr[0]); 
  
    string ans = commonPrefix(arr, 0, n-1); 
  
    if (ans.length()) 
        cout << "The longest common prefix is "
             << ans; 
    else
        cout << "There is no common prefix"; 
    return (0); 
} 

6. Rabin Karp :-
  ----------------

#include <bits/stdc++.h> 
using namespace std; 
  
// d is the number of characters in the input alphabet  
#define d 256  
  
/* pat -> pattern  
    txt -> text  
    q -> A prime number  
*/
void search(char pat[], char txt[], int q)  
{  
    int M = strlen(pat);  
    int N = strlen(txt);  
    int i, j;  
    int p = 0; // hash value for pattern  
    int t = 0; // hash value for txt  
    int h = 1;  
  
    // The value of h would be "pow(d, M-1)%q"  
    for (i = 0; i < M - 1; i++)  
        h = (h * d) % q;  
  
    // Calculate the hash value of pattern and first  
    // window of text  
    for (i = 0; i < M; i++)  
    {  
        p = (d * p + pat[i]) % q;  
        t = (d * t + txt[i]) % q;  
    }  
  
    // Slide the pattern over text one by one  
    for (i = 0; i <= N - M; i++)  
    {  
  
        // Check the hash values of current window of text  
        // and pattern. If the hash values match then only  
        // check for characters on by one  
        if ( p == t )  
        {  
            /* Check for characters one by one */
            for (j = 0; j < M; j++)  
            {  
                if (txt[i+j] != pat[j])  
                    break;  
            }  
  
            // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]  
            if (j == M)  
                cout<<"Pattern found at index "<< i<<endl;  
        }  
  
        // Calculate hash value for next window of text: Remove  
        // leading digit, add trailing digit  
        if ( i < N-M )  
        {  
            t = (d*(t - txt[i]*h) + txt[i+M])%q;  
  
            // We might get negative value of t, converting it  
            // to positive  
            if (t < 0)  
            t = (t + q);  
        }  
    }  
}  
  
/* Driver code */
int main()  
{  
    char txt[] = "GEEKS FOR GEEKS";  
    char pat[] = "GEEK"; 
        
      // A prime number  
    int q = 101;  
      
      // Function Call 
      search(pat, txt, q);  
    return 0;  
}  

Day16: (String)

1. Prefix Function/Z-Function :-
  --------------------------------

2. KMP algo :-
  -------------

3. Minimum characters needed to be inserted in the beginning to make it palindromic :-
  --------------------------------------------------------------------------------------

4. Check for Anagrams :-
  ------------------------

#include <bits/stdc++.h>
using namespace std;
 
bool isAnagram(string c, string d)
{
    if (c.size() != d.size())
        return false;
    int count = 0;
 
    // Take sum of all characters of first String
    for (int i = 0; i < c.size(); i++) {
        count += c[i];
    }
 
    // Subtract the Value of all the characters of second
    // String
    for (int i = 0; i < d.size(); i++) {
        count -= d[i];
    }
 
    // If Count = 0 then they are anagram
    // If count > 0 or count < 0 then they are not anagram
    return (count == 0);
}
 
// Driver code
int main()
{
    char str1[] = "geeksforgeeks";
    char str2[] = "forgeeksgeeks";
   
    // Function call
    if (isAnagram(str1, str2))
        cout << "The two strings are anagram of each other";
    else
        cout << "The two strings are not anagram of each "
                "other";
 
    return 0;
}

5. Count and Say :-
  -------------------

class Solution {
public:
    string countAndSay(int n) {
        string s1="1";
        int i=1;
        while(i<n)
        {
            string sp ;
            int count= 1;
            int j = 1;
            while(j<=s1.size())
            {
                if(s1[j]==s1[j-1])
                {
                    count++;
                }
                else
                {
                    sp+=to_string(count);
                    sp+=s1[j-1];
                    count= 1;
                }
                j++;
            }
            s1=sp;
            i++;
         }
        return s1;
    }
};

6. Compare version numbers :-
  -----------------------------

 int compareVersion(string version1, string version2) {
         int i=0;
        int j=0;
        int n=version1.size();
        int m=version2.size();
        int num1=0;
        int num2=0;
        while(i<n||j<m)
        {
            while(i<n&&version1[i]!='.')
            {
                num1=num1*10+version1[i]-'0';
                i++;
            }
            i++;
            while(j<m&&version2[j]!='.')
            {
                num2=num2*10+version2[j]-'0' ;
                j++;
            }
            j++;
            if(num1<num2)
                return -1;
            if(num1>num2)
                return 1;
            num1=0;
            num2=0;
                
        }
        return 0;
    }

Day17: (Binary Tree) :-
-------------------------

1. Inorder Traversal (with recursion and without recursion) :-
  ---------------------------------------------------------------
=> With recursion :-
  --------------------

void printInorder(struct Node* node) 
{ 
    if (node == NULL) 
        return; 
  
    /* first recur on left child */
    printInorder(node->left); 
  
    /* then print the data of node */
    cout << node->data << " "; 
  
    /* now recur on right child */
    printInorder(node->right); 
} 

=> Without recursion :-
  ----------------------

#include<bits/stdc++.h> 
using namespace std; 
  
/* A binary tree Node has data, pointer to left child 
   and a pointer to right child */
struct Node 
{ 
    int data; 
    struct Node* left; 
    struct Node* right; 
    Node (int data) 
    { 
        this->data = data; 
        left = right = NULL; 
    } 
}; 
  
/* Iterative function for inorder tree 
   traversal */
void inOrder(struct Node *root) 
{ 
    stack<Node *> s; 
    Node *curr = root; 
  
    while (curr != NULL || s.empty() == false) 
    { 
        /* Reach the left most Node of the 
           curr Node */
        while (curr !=  NULL) 
        { 
            /* place pointer to a tree node on 
               the stack before traversing 
              the node's left subtree */
            s.push(curr); 
            curr = curr->left; 
        } 
  
        /* Current must be NULL at this point */
        curr = s.top(); 
        s.pop(); 
  
        cout << curr->data << " "; 
  
        /* we have visited the node and its 
           left subtree.  Now, it's right 
           subtree's turn */
        curr = curr->right; 
  
    } /* end of while */
} 

2. Preorder Traversal (with recursion and without recursion) :-
  -----------------------------------------------------------------

=> With recursion :-
  --------------------

void printPreorder(struct Node* node) 
{ 
    if (node == NULL) 
        return; 
  
    /* first print data of node */
    cout << node->data << " "; 
  
    /* then recur on left sutree */
    printPreorder(node->left);  
  
    /* now recur on right subtree */
    printPreorder(node->right); 
}  

=> Without recursion :-
  ----------------------

#include <bits/stdc++.h>
 
using namespace std;
 
/* A binary tree node has data, left child and right child */
struct node {
    int data;
    struct node* left;
    struct node* right;
};
 
/* Helper function that allocates a new node with the given data and
   NULL left and right  pointers.*/
struct node* newNode(int data)
{
    struct node* node = new struct node;
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    return (node);
}
 
// An iterative process to print preorder traversal of Binary tree
void iterativePreorder(node* root)
{
    // Base Case
    if (root == NULL)
        return;
 
    // Create an empty stack and push root to it
    stack<node*> nodeStack;
    nodeStack.push(root);
 
    /* Pop all items one by one. Do following for every popped item
       a) print it
       b) push its right child
       c) push its left child
    Note that right child is pushed first so that left is processed first */
    while (nodeStack.empty() == false) {
        // Pop the top item from stack and print it
        struct node* node = nodeStack.top();
        printf("%d ", node->data);
        nodeStack.pop();
 
        // Push right and left children of the popped node to stack
        if (node->right)
            nodeStack.push(node->right);
        if (node->left)
            nodeStack.push(node->left);
    }
}
 
// Driver program to test above functions
int main()
{
    /* Constructed binary tree is
            10
          /   \
        8      2
      /  \    /
    3     5  2
  */
    struct node* root = newNode(10);
    root->left = newNode(8);
    root->right = newNode(2);
    root->left->left = newNode(3);
    root->left->right = newNode(5);
    root->right->left = newNode(2);
    iterativePreorder(root);
    return 0;
}

3. Postorder Traversal (with recursion and without recursion) :-
  -----------------------------------------------------------------

=> With recursion :-
  --------------------

void printPostorder(struct Node* node) 
{ 
    if (node == NULL) 
        return; 
  
    // first recur on left subtree 
    printPostorder(node->left); 
  
    // then recur on right subtree 
    printPostorder(node->right); 
  
    // now deal with the node 
    cout << node->data << " "; 
} 

=> Without recursion :-
  ----------------------

private void postOrderIterative(Node root) {
        Stack<Node> stack = new Stack<>();
        while(true) {
            while(root != null) {
                stack.push(root);
                stack.push(root);
                root = root.left;
            }
             
            // Check for empty stack
            if(stack.empty()) return;
            root = stack.pop();
             
            if(!stack.empty() && stack.peek() == root) root = root.right;
             
            else {
                 
                System.out.print(root.data + " "); root = null;
            }
        }
    }

4. LeftView Of Binary Tree :-
  ------------------------------

void printRightView(Node* root) 
{ 
    if (!root) 
        return; 
 
    queue<Node*> q; 
    q.push(root); 
 
    while (!q.empty()) 
    {     
        // number of nodes at current level 
        int n = q.size(); 
         
        // Traverse all nodes of current level 
        for(int i = 1; i <= n; i++) 
        { 
            Node* temp = q.front(); 
            q.pop(); 
                 
            // Print the left most element 
            // at the level 
            if (i == 1) 
                cout<<temp->data<<" "; 
             
            // Add left node to queue 
            if (temp->left != NULL) 
                q.push(temp->left); 
 
            // Add right node to queue 
            if (temp->right != NULL) 
                q.push(temp->right); 
        } 
    } 
}     

5. Bottom View of Binary Tree :-
  --------------------------------

void bottomView(Node *root) 
{ 
    if (root == NULL) 
        return; 
  
    // Initialize a variable 'hd' with 0 
    // for the root element. 
    int hd = 0; 
  
    // TreeMap which stores key value pair 
    // sorted on key value 
    map<int, int> m; 
  
    // Queue to store tree nodes in level 
    // order traversal 
    queue<Node *> q; 
  
    // Assign initialized horizontal distance 
    // value to root node and add it to the queue. 
    root->hd = hd; 
    q.push(root);  // In STL, push() is used enqueue an item 
  
    // Loop until the queue is empty (standard 
    // level order loop) 
    while (!q.empty()) 
    { 
        Node *temp = q.front(); 
        q.pop();   // In STL, pop() is used dequeue an item 
  
        // Extract the horizontal distance value 
        // from the dequeued tree node. 
        hd = temp->hd; 
  
        // Put the dequeued tree node to TreeMap 
        // having key as horizontal distance. Every 
        // time we find a node having same horizontal 
        // distance we need to replace the data in 
        // the map. 
        m[hd] = temp->data; 
  
        // If the dequeued node has a left child, add 
        // it to the queue with a horizontal distance hd-1. 
        if (temp->left != NULL) 
        { 
            temp->left->hd = hd-1; 
            q.push(temp->left); 
        } 
  
        // If the dequeued node has a right child, add 
        // it to the queue with a horizontal distance 
        // hd+1. 
        if (temp->right != NULL) 
        { 
            temp->right->hd = hd+1; 
            q.push(temp->right); 
        } 
    } 
  
    // Traverse the map elements using the iterator. 
    for (auto i = m.begin(); i != m.end(); ++i) 
        cout << i->second << " "; 
} 

6. Top View of Binary Tree :-
  -----------------------------

void topview(Node* root)
{
    if(root==NULL)
       return;
     queue<Node*>q;
     map<int,int> m; 
     int hd=0;
     root->hd=hd;
      
     // push node and horizontal distance to queue
    q.push(root);
     
    cout<< "The top view of the tree is : \n";
     
    while(q.size())
    {
        hd=root->hd;
         
        // count function returns 1 if the container 
        // contains an element whose key is equivalent 
        // to hd, or returns zero otherwise.
        if(m.count(hd)==0)  
        m[hd]=root->data;
        if(root->left)
        {
            root->left->hd=hd-1;
            q.push(root->left);
        }
        if(root->right)
        {
            root->right->hd=hd+1;
            q.push(root->right);
        }
        q.pop();
        root=q.front();
       
    }
     
     
     
     for(auto i=m.begin();i!=m.end();i++)
    {
        cout<<i->second<<" ";
    }
     
}

Day18: (Binary Tree) :-
---------------------------

1. Level order Traversal :-
  -------------------------------------------------------------------

#include <bits/stdc++.h>
using namespace std;
 
// A Binary Tree Node
struct Node
{
    int data;
    struct Node *left, *right;
};
 
// Iterative method to find height of Binary Tree
void printLevelOrder(Node *root)
{
    // Base Case
    if (root == NULL)  return;
 
    // Create an empty queue for level order traversal
    queue<Node *> q;
 
    // Enqueue Root and initialize height
    q.push(root);
 
    while (q.empty() == false)
    {
        // Print front of queue and remove it from queue
        Node *node = q.front();
        cout << node->data << " ";
        q.pop();
 
        /* Enqueue left child */
        if (node->left != NULL)
            q.push(node->left);
 
        /*Enqueue right child */
        if (node->right != NULL)
            q.push(node->right);
    }
}
 
// Utility function to create a new tree node
Node* newNode(int data)
{
    Node *temp = new Node;
    temp->data = data;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Driver program to test above functions
int main()
{
    // Let us create binary tree shown in above diagram
    Node *root = newNode(1);
    root->left = newNode(2);
    root->right = newNode(3);
    root->left->left = newNode(4);
    root->left->right = newNode(5);
 
    cout << "Level Order traversal of binary tree is \n";
    printLevelOrder(root);
    return 0;
}

 => Level order traversal in spiral form :-
   ------------------------------------------

void printSpiral(struct node* root) 
{ 
    if (root == NULL) 
        return; // NULL check 
  
    // Create two stacks to store alternate levels 
    stack<struct node*> s1; // For levels to be printed from right to left 
    stack<struct node*> s2; // For levels to be printed from left to right 
  
    // Push first level to first stack 's1' 
    s1.push(root); 
  
    // Keep printing while any of the stacks has some nodes 
    while (!s1.empty() || !s2.empty()) { 
        // Print nodes of current level from s1 and push nodes of 
        // next level to s2 
        while (!s1.empty()) { 
            struct node* temp = s1.top(); 
            s1.pop(); 
            cout << temp->data << " "; 
  
            // Note that is right is pushed before left 
            if (temp->right) 
                s2.push(temp->right); 
            if (temp->left) 
                s2.push(temp->left); 
        } 
  
        // Print nodes of current level from s2 and push nodes of 
        // next level to s1 
        while (!s2.empty()) { 
            struct node* temp = s2.top(); 
            s2.pop(); 
            cout << temp->data << " "; 
  
            // Note that is left is pushed before right 
            if (temp->left) 
                s1.push(temp->left); 
            if (temp->right) 
                s1.push(temp->right); 
        } 
    } 
} 

2. Height of a Binary Tree :-
  -----------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
  
/* A binary tree node has data, pointer to left child 
and a pointer to right child */
class node  
{  
    public: 
    int data;  
    node* left;  
    node* right;  
};  
  
/* Compute the "maxDepth" of a tree -- the number of  
    nodes along the longest path from the root node  
    down to the farthest leaf node.*/
int maxDepth(node* node)  
{  
    if (node == NULL)  
        return 0;  
    else
    {  
        /* compute the depth of each subtree */
        int lDepth = maxDepth(node->left);  
        int rDepth = maxDepth(node->right);  
      
        /* use the larger one */
        if (lDepth > rDepth)  
            return(lDepth + 1);  
        else return(rDepth + 1);  
    }  
}  
  
/* Helper function that allocates a new node with the  
given data and NULL left and right pointers. */
node* newNode(int data)  
{  
    node* Node = new node(); 
    Node->data = data;  
    Node->left = NULL;  
    Node->right = NULL;  
      
    return(Node);  
}  
      
// Driver code     
int main()  
{  
    node *root = newNode(1);  
  
    root->left = newNode(2);  
    root->right = newNode(3);  
    root->left->left = newNode(4);  
    root->left->right = newNode(5);  
      
    cout << "Height of tree is " << maxDepth(root);  
    return 0;  
}  

3. Diameter of Binary Tree :-
  ----------------------------

int diameter(Node *p)
{
	if(p==NULL)
		return 0;
	int lheight= height(p->left); // write the height function too
	int rheight=height(p->right);
	int ldiameter=diameter(p->left);
	int rdiameter=diameter(p->right);
	int fd=max(1+lheight+rheight ,max(ldiameter,rdiameter));
	return fd;
}

4. Check if Binary tree is height balanced or not :-
  ----------------------------------------------------

class Solution {
    boolean isBalanced = true;

	public boolean isBalanced(TreeNode root) {
		heightOfTree(root);
		return isBalanced;
	}

	private int heightOfTree(TreeNode root) {
		if (root == null) {
			return 0;
		}
		int lHeight = heightOfTree(root.left);
		int rHeight = heightOfTree(root.right);
		if(Math.abs(lHeight - rHeight) > 1) {
			isBalanced = false;
		}
		return 1 + Math.max(lHeight, rHeight);
	}
}

5. LCA in Binary Tree :-
  ------------------------

struct Node *findLCA(struct Node* root, int n1, int n2)
{
    // Base case
    if (root == NULL) return NULL;
 
    // If either n1 or n2 matches with root's key, report
    // the presence by returning root (Note that if a key is
    // ancestor of other, then the ancestor key becomes LCA
    if (root->key == n1 || root->key == n2)
        return root;
 
    // Look for keys in left and right subtrees
    Node *left_lca  = findLCA(root->left, n1, n2);
    Node *right_lca = findLCA(root->right, n1, n2);
 
    // If both of the above calls return Non-NULL, then one key
    // is present in once subtree and other is present in other,
    // So this node is the LCA
    if (left_lca && right_lca)  return root;
 
    // Otherwise check if left subtree or right subtree is LCA
    return (left_lca != NULL)? left_lca: right_lca;
}

6. Check if two trees are identical or not :-
  ---------------------------------------------

int identicalTrees(node* a, node* b)  
{  
    /*1. both empty */
    if (a == NULL && b == NULL)  
        return 1;  
  
    /* 2. both non-empty -> compare them */
    if (a != NULL && b != NULL)  
    {  
        return
        (  
            a->data == b->data &&  
            identicalTrees(a->left, b->left) &&  
            identicalTrees(a->right, b->right)  
        );  
    }  
      
    /* 3. one empty, one not -> false */
    return 0;  
}  

Day 19: (Binary Tree) :-
--------------------------

1. Maximum path sum :-
  ----------------------

int findMaxUtil(Node* root, int &res) 
{ 
    //Base Case 
    if (root == NULL) 
        return 0; 
  
    // l and r store maximum path sum going through left and 
    // right child of root respectively 
    int l = findMaxUtil(root->left,res); 
    int r = findMaxUtil(root->right,res); 
  
    // Max path for parent call of root. This path must 
    // include at-most one child of root 
    int max_single = max(max(l, r) + root->data, root->data); 
  
    // Max Top represents the sum when the Node under 
    // consideration is the root of the maxsum path and no 
    // ancestors of root are there in max sum path 
    int max_top = max(max_single, l + r + root->data); 
  
    res = max(res, max_top); // Store the Maximum Result. 
  
    return max_single; 
} 
  
// Returns maximum path sum in tree with given root 
int findMaxSum(Node *root) 
{ 
    // Initialize result 
    int res = INT_MIN; 
  
    // Compute and return result 
    findMaxUtil(root, res); 
    return res; 
} 

2. Construct Binary Tree from inorder and preorder :-
  -----------------------------------------------------

struct Node* buildTree(char in[], char pre[], int inStrt,
                       int inEnd, unordered_map<char, int>& mp)
{
    static int preIndex = 0;
 
    if (inStrt > inEnd)
        return NULL;
 
    /* Pick current node from Preorder traversal using preIndex 
    and increment preIndex */
    char curr = pre[preIndex++];
    struct Node* tNode = newNode(curr);
 
    /* If this node has no children then return */
    if (inStrt == inEnd)
        return tNode;
 
    /* Else find the index of this node in Inorder traversal */
    int inIndex = mp[curr];
 
    /* Using index in Inorder traversal, construct left and 
    right subtress */
    tNode->left = buildTree(in, pre, inStrt, inIndex - 1, mp);
    tNode->right = buildTree(in, pre, inIndex + 1, inEnd, mp);
 
    return tNode;
}
 
// This function mainly creates an unordered_map, then
// calls buildTree()
struct Node* buldTreeWrap(char in[], char pre[], int len)
{
    // Store indexes of all items so that we
    // we can quickly find later
    unordered_map<char, int> mp;
    for (int i = 0; i < len; i++)
        mp[in[i]] = i;
 
    return buildTree(in, pre, 0, len - 1, mp);
}
 
/* This funtcion is here just to test buildTree() */
void printInorder(struct Node* node)
{
    if (node == NULL)
        return;
    printInorder(node->left);
    printf("%c ", node->data);
    printInorder(node->right);
}
 
/* Driver program to test above functions */
int main()
{
    char in[] = { 'D', 'B', 'E', 'A', 'F', 'C' };
    char pre[] = { 'A', 'B', 'D', 'E', 'C', 'F' };
    int len = sizeof(in) / sizeof(in[0]);
 
    struct Node* root = buldTreeWrap(in, pre, len);
 
    /* Let us test the built tree by printing 
      Insorder traversal */
    printf("Inorder traversal of the constructed tree is \n");
    printInorder(root);
}

3. Construct Binary Tree from Inorder and Postorder :-
  ------------------------------------------------------

Node* buildUtil(int in[], int post[], int inStrt,
    int inEnd, int* pIndex, unordered_map<int, int>& mp)
{
    // Base case
    if (inStrt > inEnd)
        return NULL;
 
    /* Pick current node from Postorder traversal  
    using postIndex and decrement postIndex */
    int curr = post[*pIndex];
    Node* node = newNode(curr);
    (*pIndex)--;
 
    /* If this node has no children then return */
    if (inStrt == inEnd)
        return node;
 
    /* Else find the index of this node in Inorder 
    traversal */
    int iIndex = mp[curr];
 
    /* Using index in Inorder traversal, construct 
    left and right subtress */
    node->right = buildUtil(in, post, iIndex + 1,
                            inEnd, pIndex, mp);
    node->left = buildUtil(in, post, inStrt,
                           iIndex - 1, pIndex, mp);
 
    return node;
}
 
// This function mainly creates an unordered_map, then
// calls buildTreeUtil()
struct Node* buildTree(int in[], int post[], int len)
{
    // Store indexes of all items so that we
    // we can quickly find later
    unordered_map<int, int> mp;
    for (int i = 0; i < len; i++)
        mp[in[i]] = i;
 
    int index = len - 1; // Index in postorder
    return buildUtil(in, post, 0, len - 1,
                     &index, mp);
}

4. Symmetric Binary Tree / Check if Binary Tree is mirror of itself or not :-
  ----------------------------------------------------------------------------

bool isMirror(struct Node *root1, struct Node *root2) 
{ 
    // If both trees are emptu, then they are mirror images 
    if (root1 == NULL && root2 == NULL) 
        return true; 
  
    // For two trees to be mirror images, the following three 
    // conditions must be true 
    // 1 - Their root node's key must be same 
    // 2 - left subtree of left tree and right subtree 
    //      of right tree have to be mirror images 
    // 3 - right subtree of left tree and left subtree 
    //      of right tree have to be mirror images 
    if (root1 && root2 && root1->key == root2->key) 
        return isMirror(root1->left, root2->right) && 
               isMirror(root1->right, root2->left); 
  
    // if neither of above conditions is true then root1 
    // and root2 are not mirror images 
    return false; 
} 
  
// Returns true if a tree is symmetric i.e. mirror image of itself 
bool isSymmetric(struct Node* root) 
{ 
    // Check if tree is mirror of itself 
    return isMirror(root, root); 
} 
  
// Driver program 
int main() 
{ 
    // Let us construct the Tree shown in the above figure 
    Node *root        = newNode(1); 
    root->left        = newNode(2); 
    root->right       = newNode(2); 
    root->left->left  = newNode(3); 
    root->left->right = newNode(4); 
    root->right->left  = newNode(4); 
    root->right->right = newNode(3); 
  
    cout << isSymmetric(root); 
    return 0; 
} 

5. Flatten Binary Tree to LinkedList :-
  ---------------------------------------

void flatten(struct Node* root)
{
    // base condition- return if root is NULL
    // or if it is a leaf node
    if (root == NULL || root->left == NULL &&
                        root->right == NULL) {
        return;
    }
 
    // if root->left exists then we have 
    // to make it root->right
    if (root->left != NULL) {
 
        // move left recursively
        flatten(root->left);
    
        // store the node root->right
        struct Node* tmpRight = root->right;
        root->right = root->left;
        root->left = NULL;
 
        // find the position to insert
        // the stored value   
        struct Node* t = root->right;
        while (t->right != NULL) {
            t = t->right;
        }
 
        // insert the stored value
        t->right = tmpRight;
    }
 
    // now call the same function
    // for root->right
    flatten(root->right);
}

Day 20: (Binary Search Tree) :-
---------------------------------

1. Populate Next Right pointers of Tree :-
  ------------------------------------------
Node* connect(Node* root)
    {
        if(!root)
            return root;
        Node* curr=nullptr;
        Node* prev=root;
        while(prev->left)
        {
            curr=prev;
            while(curr)
            {
                curr->left->next=curr->right;
                if(curr->next)
                    curr->right->next=curr->next->left;
                curr=curr->next;
            }
            prev=prev->left;
        }
       return root;
    }

2. Search given Key in BST :-
  -------------------------------


struct node* search(struct node* root, int key) 
{ 
    // Base Cases: root is null or key is present at root 
    if (root == NULL || root->key == key) 
       return root; 
     
    // Key is greater than root's key 
    if (root->key < key) 
       return search(root->right, key); 
  
    // Key is smaller than root's key 
    return search(root->left, key); 
}

3. Construct BST from given keys :-
  ------------------------------------

BST* BST ::Insert(BST* root, int value) 
{ 
    if (!root)  
    { 
        // Insert the first node, if root is NULL. 
        return new BST(value); 
    } 
  
    // Insert data. 
    if (value > root->data)  
    { 
        // Insert right node data, if the 'value' 
        // to be inserted is greater than 'root' node data. 
  
        // Process right nodes. 
        root->right = Insert(root->right, value); 
    } 
    else 
    { 
        // Insert left node data, if the 'value' 
        // to be inserted is greater than 'root' node data. 
  
        // Process left nodes. 
        root->left = Insert(root->left, value); 
    } 
  
    // Return 'root' node, after insertion. 
    return root; 
} 

// Driver code 
int main() 
{ 
    BST b, *root = NULL; 
    root = b.Insert(root, 50); 
    b.Insert(root, 30); 
    b.Insert(root, 20); 
    b.Insert(root, 40); 
    b.Insert(root, 70); 
    b.Insert(root, 60); 
    b.Insert(root, 80); 
    return 0; 
}

4. Check is a BT is BST or not :-
  --------------------------------

Do inorder traversal if obtained array is sorted than it is bst else not.

5. Find LCA of two nodes in BST :-
  ----------------------------------

#include <stdio.h> 
#include <stdlib.h> 
  
struct node 
{ 
    int data; 
    struct node* left, *right; 
}; 
  
/* Function to find LCA of n1 and n2. The function assumes that both 
   n1 and n2 are present in BST */
struct node *lca(struct node* root, int n1, int n2) 
{ 
    if (root == NULL) return NULL; 
  
    // If both n1 and n2 are smaller than root, then LCA lies in left 
    if (root->data > n1 && root->data > n2) 
        return lca(root->left, n1, n2); 
  
    // If both n1 and n2 are greater than root, then LCA lies in right 
    if (root->data < n1 && root->data < n2) 
        return lca(root->right, n1, n2); 
  
    return root; 
} 
  
/* Helper function that allocates a new node with the given data.*/
struct node* newNode(int data) 
{ 
    struct node* node = (struct node*)malloc(sizeof(struct node)); 
    node->data  = data; 
    node->left  = node->right = NULL; 
    return(node); 
} 
  
/* Driver program to test lca() */
int main() 
{ 
    // Let us construct the BST shown in the above figure 
    struct node *root        = newNode(20); 
    root->left               = newNode(8); 
    root->right              = newNode(22); 
    root->left->left         = newNode(4); 
    root->left->right        = newNode(12); 
    root->left->right->left  = newNode(10); 
    root->left->right->right = newNode(14); 
  
    int n1 = 10, n2 = 14; 
    struct node *t = lca(root, n1, n2); 
    printf("LCA of %d and %d is %d \n", n1, n2, t->data); 
  
    n1 = 14, n2 = 8; 
    t = lca(root, n1, n2); 
    printf("LCA of %d and %d is %d \n", n1, n2, t->data); 
  
    n1 = 10, n2 = 22; 
    t = lca(root, n1, n2); 
    printf("LCA of %d and %d is %d \n", n1, n2, t->data); 
  
    getchar(); 
    return 0; 
} 

6. Find the inorder predecessor/successor of a given Key in BST :-
  ------------------------------------------------------------------

void findPreSuc(Node* root, Node*& pre, Node*& suc, int key) 
{ 
    // Base case 
    if (root == NULL)  return ; 
  
    // If key is present at root 
    if (root->key == key) 
    { 
        // the maximum value in left subtree is predecessor 
        if (root->left != NULL) 
        { 
            Node* tmp = root->left; 
            while (tmp->right) 
                tmp = tmp->right; 
            pre = tmp ; 
        } 
  
        // the minimum value in right subtree is successor 
        if (root->right != NULL) 
        { 
            Node* tmp = root->right ; 
            while (tmp->left) 
                tmp = tmp->left ; 
            suc = tmp ; 
        } 
        return ; 
    } 
  
    // If key is smaller than root's key, go to left subtree 
    if (root->key > key) 
    { 
        suc = root ; 
        findPreSuc(root->left, pre, suc, key) ; 
    } 
    else // go to right subtree 
    { 
        pre = root ; 
        findPreSuc(root->right, pre, suc, key) ; 
    } 
} 
  

Day21: (BinarySearchTree) :-
-------------------------------

1. Floor and Ceil in a BST :-
  -----------------------------

int floor(Node* root, int key) 
{ 
    if (!root) 
        return INT_MAX; 
  
    /* If root->data is equal to key */
    if (root->data == key) 
        return root->data; 
  
    /* If root->data is greater than the key */
    if (root->data > key) 
        return floor(root->left, key); 
  
    /* Else, the floor may lie in right subtree 
      or may be equal to the root*/
    int floorValue = floor(root->right, key); 
    return (floorValue <= key) ? floorValue : root->data; 
} 


int Ceil(node* root, int input) 
{ 
    // Base case 
    if (root == NULL) 
        return -1; 
 
    // We found equal key 
    if (root->key == input) 
        return root->key; 
 
    // If root's key is smaller, ceil must be in right subtree 
    if (root->key < input) 
        return Ceil(root->right, input); 
 
    // Else, either left subtree or root has the ceil value 
    int ceil = Ceil(root->left, input); 
    return (ceil >= input) ? ceil : root->key; 
} 
 
2. Find K-th smallest and K-th largest element in BST (2 different Questions) :- 
  ----------------------------------------------------------------------------------

(i) Kth Smallest :-
   ------------------

Node* kthSmallest(Node* root, int& k)
{
    // base case
    if (root == NULL)
        return NULL;
 
    // search in left subtree
    Node* left = kthSmallest(root->left, k);
 
    // if k'th smallest is found in left subtree, return it
    if (left != NULL)
        return left;
 
    // if current element is k'th smallest, return it
    k--;
    if (k == 0)
        return root;
 
    // else search in right subtree
    return kthSmallest(root->right, k);
}

(ii)  K-th largest element in BST :-
     ---------------------------------

Node* kthLargest(Node* root, int& k)
{
    // base case
    if (root == NULL)
        return NULL;
 
    // search in right subtree
    Node* right = kthLargest(root->right, k);
 
    // if k'th smallest is found in left subtree, return it
    if (right != NULL)
        return right;
 
    // if current element is k'th Largest, return it
    k--;
    if (k == 0)
        return root;
 
    // else search in right subtree
    return kthLargest(root->left, k);
}

Day23: (Graph) : -
----------------------

6. Number of islands (Do in Grid and Graph both) : -
-----------------------------------------------------------
//  memset(visited, 0, sizeof(visited)); => memset is used to fill an array or block,
// first pos=pointer, 2nd=value by which it should be filled,3rd=no.of block to be filled 

#include <bits/stdc++.h>
using namespace std;
 
#define ROW 5
#define COL 5
 
// A function to check if a given
// cell (row, col) can be included in DFS
int isSafe(int M[][COL], int row, int col,
           bool visited[][COL])
{
    // row number is in range, column
    // number is in range and value is 1
    // and not yet visited
    return (row >= 0) && (row < ROW) && (col >= 0) && (col < COL) && (M[row][col] && !visited[row][col]);
}
 
// A utility function to do DFS for a
// 2D boolean matrix. It only considers
// the 8 neighbours as adjacent vertices
void DFS(int M[][COL], int row, int col,
         bool visited[][COL])
{
    // These arrays are used to get
    // row and column numbers of 8
    // neighbours of a given cell
    static int rowNbr[] = { -1, -1, -1, 0, 0, 1, 1, 1 };
    static int colNbr[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
 
    // Mark this cell as visited
    visited[row][col] = true;
 
    // Recur for all connected neighbours
    for (int k = 0; k < 8; ++k)
        if (isSafe(M, row + rowNbr[k], col + colNbr[k], visited))
            DFS(M, row + rowNbr[k], col + colNbr[k], visited);
}
 
// The main function that returns
// count of islands in a given boolean
// 2D matrix
int countIslands(int M[][COL])
{
    // Make a bool array to mark visited cells.
    // Initially all cells are unvisited
    bool visited[ROW][COL];
    memset(visited, 0, sizeof(visited));
 
    // Initialize count as 0 and
    // travese through the all cells of
    // given matrix
    int count = 0;
    for (int i = 0; i < ROW; ++i)
        for (int j = 0; j < COL; ++j)
 
            // If a cell with value 1 is not
            if (M[i][j] && !visited[i][j]) {
                // visited yet, then new island found
                // Visit all cells in this island.
                DFS(M, i, j, visited);
 
                // and increment island count
                ++count;
            }
 
    return count;
}
 
// Driver code
int main()
{
    int M[][COL] = { { 1, 1, 0, 0, 0 },
                     { 0, 1, 0, 0, 1 },
                     { 1, 0, 0, 1, 1 },
                     { 0, 0, 0, 0, 0 },
                     { 1, 0, 1, 0, 1 } };
 
    cout << "Number of islands is: " << countIslands(M);
 
    return 0;
}

7. Bipartite Check :-
  --------------------
  #include <bits/stdc++.h>
 
using namespace std;
 
const int V = 4;
 
// This function returns true if
// graph G[V][V] is Bipartite, else false
bool isBipartiteUtil(int G[][V], int src, int colorArr[])
{
    colorArr[src] = 1;
 
    // Create a queue (FIFO) of vertex numbers a
    // nd enqueue source vertex for BFS traversal
    queue<int> q;
    q.push(src);
 
    // Run while there are vertices in queue (Similar to
    // BFS)
    while (!q.empty()) {
        // Dequeue a vertex from queue ( Refer
        // http://goo.gl/35oz8 )
        int u = q.front();
        q.pop();
 
        // Return false if there is a self-loop
        if (G[u][u] == 1)
            return false;
 
        // Find all non-colored adjacent vertices
        for (int v = 0; v < V; ++v) {
            // An edge from u to v exists and
            // destination v is not colored
            if (G[u][v] && colorArr[v] == -1) {
                // Assign alternate color to this
                // adjacent v of u
                colorArr[v] = 1 - colorArr[u];
                q.push(v);
            }
 
            // An edge from u to v exists and destination
            // v is colored with same color as u
            else if (G[u][v] && colorArr[v] == colorArr[u])
                return false;
        }
    }
 
    // If we reach here, then all adjacent vertices can
    // be colored with alternate color
    return true;
}
 
// Returns true if G[][] is Bipartite, else false
bool isBipartite(int G[][V])
{
    // Create a color array to store colors assigned to all
    // veritces. Vertex/ number is used as index in this
    // array. The value '-1' of colorArr[i] is used to
    // ndicate that no color is assigned to vertex 'i'.
    // The value 1 is used to indicate first color is
    // assigned and value 0 indicates second color is
    // assigned.
    int colorArr[V];
    for (int i = 0; i < V; ++i)
        colorArr[i] = -1;
 
    // This code is to handle disconnected graoh
    for (int i = 0; i < V; i++)
        if (colorArr[i] == -1)
            if (isBipartiteUtil(G, i, colorArr) == false)
                return false;
 
    return true;
}
 
// Driver code
int main()
{
    int G[][V] = { { 0, 1, 0, 1 },
                   { 1, 0, 1, 0 },
                   { 0, 1, 0, 1 },
                   { 1, 0, 1, 0 } };
 
    isBipartite(G) ? cout << "Yes" : cout << "No";
    return 0;
}

Day24: (Graph)
----------------
1. SCC(using KosaRaju’s algo) :-
  -------------------------------
#include <iostream>
#include <list>
#include <stack>
using namespace std;
  
class Graph
{
    int V;    // No. of vertices
    list<int> *adj;    // An array of adjacency lists
  
    // Fills Stack with vertices (in increasing order of finishing
    // times). The top element of stack has the maximum finishing 
    // time
    void fillOrder(int v, bool visited[], stack<int> &Stack);
  
    // A recursive function to print DFS starting from v
    void DFSUtil(int v, bool visited[]);
public:
    Graph(int V);
    void addEdge(int v, int w);
  
    // The main function that finds and prints strongly connected
    // components
    void printSCCs();
  
    // Function that returns reverse (or transpose) of this graph
    Graph getTranspose();
};
  
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];
}
  
// A recursive function to print DFS starting from v
void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and print it
    visited[v] = true;
    cout << v << " ";
  
    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}
  
Graph Graph::getTranspose()
{
    Graph g(V);
    for (int v = 0; v < V; v++)
    {
        // Recur for all the vertices adjacent to this vertex
        list<int>::iterator i;
        for(i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            g.adj[*i].push_back(v);
        }
    }
    return g;
}
  
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}
  
void Graph::fillOrder(int v, bool visited[], stack<int> &Stack)
{
    // Mark the current node as visited and print it
    visited[v] = true;
  
    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for(i = adj[v].begin(); i != adj[v].end(); ++i)
        if(!visited[*i])
            fillOrder(*i, visited, Stack);
  
    // All vertices reachable from v are processed by now, push v 
    Stack.push(v);
}
  
// The main function that finds and prints all strongly connected 
// components
void Graph::printSCCs()
{
    stack<int> Stack;
  
    // Mark all the vertices as not visited (For first DFS)
    bool *visited = new bool[V];
    for(int i = 0; i < V; i++)
        visited[i] = false;
  
    // Fill vertices in stack according to their finishing times
    for(int i = 0; i < V; i++)
        if(visited[i] == false)
            fillOrder(i, visited, Stack);
  
    // Create a reversed graph
    Graph gr = getTranspose();
  
    // Mark all the vertices as not visited (For second DFS)
    for(int i = 0; i < V; i++)
        visited[i] = false;
  
    // Now process all vertices in order defined by Stack
    while (Stack.empty() == false)
    {
        // Pop a vertex from stack
        int v = Stack.top();
        Stack.pop();
  
        // Print Strongly connected component of the popped vertex
        if (visited[v] == false)
        {
            gr.DFSUtil(v, visited);
            cout << endl;
        }
    }
}
  
// Driver program to test above functions
int main()
{
    // Create a graph given in the above diagram
    Graph g(5);
    g.addEdge(1, 0);
    g.addEdge(0, 2);
    g.addEdge(2, 1);
    g.addEdge(0, 3);
    g.addEdge(3, 4);
  
    cout << "Following are strongly connected components in "
            "given graph \n";
    g.printSCCs();
  
    return 0;
}

2. Dijsktra’s Algorithm :-
  -------------------------
  
  #include <limits.h>
#include <stdio.h>
  
// Number of vertices in the graph
#define V 9
  
// A utility function to find the vertex with minimum distance value, from
// the set of vertices not yet included in shortest path tree
int minDistance(int dist[], bool sptSet[])
{
    // Initialize min value
    int min = INT_MAX, min_index;
  
    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;
  
    return min_index;
}
  
// A utility function to print the constructed distance array
void printSolution(int dist[])
{
    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++)
        printf("%d \t\t %d\n", i, dist[i]);
}
  
// Function that implements Dijkstra's single source shortest path algorithm
// for a graph represented using adjacency matrix representation
void dijkstra(int graph[V][V], int src)
{
    int dist[V]; // The output array.  dist[i] will hold the shortest
    // distance from src to i
  
    bool sptSet[V]; // sptSet[i] will be true if vertex i is included in shortest
    // path tree or shortest distance from src to i is finalized
  
    // Initialize all distances as INFINITE and stpSet[] as false
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;
  
    // Distance of source vertex from itself is always 0
    dist[src] = 0;
  
    // Find shortest path for all vertices
    for (int count = 0; count < V - 1; count++) {
        // Pick the minimum distance vertex from the set of vertices not
        // yet processed. u is always equal to src in the first iteration.
        int u = minDistance(dist, sptSet);
  
        // Mark the picked vertex as processed
        sptSet[u] = true;
  
        // Update dist value of the adjacent vertices of the picked vertex.
        for (int v = 0; v < V; v++)
  
            // Update dist[v] only if is not in sptSet, there is an edge from
            // u to v, and total weight of path from src to  v through u is
            // smaller than current value of dist[v]
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX
                && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }
  
    // print the constructed distance array
    printSolution(dist);
}
  
// driver program to test above function
int main()
{
    /* Let us create the example graph discussed above */
    int graph[V][V] = { { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
                        { 4, 0, 8, 0, 0, 0, 0, 11, 0 },
                        { 0, 8, 0, 7, 0, 4, 0, 0, 2 },
                        { 0, 0, 7, 0, 9, 14, 0, 0, 0 },
                        { 0, 0, 0, 9, 0, 10, 0, 0, 0 },
                        { 0, 0, 4, 14, 10, 0, 2, 0, 0 },
                        { 0, 0, 0, 0, 0, 2, 0, 1, 6 },
                        { 8, 11, 0, 0, 0, 0, 1, 0, 7 },
                        { 0, 0, 2, 0, 0, 0, 6, 7, 0 } };
  
    dijkstra(graph, 0);
  
    return 0;
}


3. Bellman Ford Algo :-
  ------------------------
  
  #include <bits/stdc++.h>
  
// a structure to represent a weighted edge in graph
struct Edge {
    int src, dest, weight;
};
  
// a structure to represent a connected, directed and
// weighted graph
struct Graph {
    // V-> Number of vertices, E-> Number of edges
    int V, E;
  
    // graph is represented as an array of edges.
    struct Edge* edge;
};
  
// Creates a graph with V vertices and E edges
struct Graph* createGraph(int V, int E)
{
    struct Graph* graph = new Graph;
    graph->V = V;
    graph->E = E;
    graph->edge = new Edge[E];
    return graph;
}
  
// A utility function used to print the solution
void printArr(int dist[], int n)
{
    printf("Vertex   Distance from Source\n");
    for (int i = 0; i < n; ++i)
        printf("%d \t\t %d\n", i, dist[i]);
}
  
// The main function that finds shortest distances from src to
// all other vertices using Bellman-Ford algorithm.  The function
// also detects negative weight cycle
void BellmanFord(struct Graph* graph, int src)
{
    int V = graph->V;
    int E = graph->E;
    int dist[V];
  
    // Step 1: Initialize distances from src to all other vertices
    // as INFINITE
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX;
    dist[src] = 0;
  
    // Step 2: Relax all edges |V| - 1 times. A simple shortest
    // path from src to any other vertex can have at-most |V| - 1
    // edges
    for (int i = 1; i <= V - 1; i++) {
        for (int j = 0; j < E; j++) {
            int u = graph->edge[j].src;
            int v = graph->edge[j].dest;
            int weight = graph->edge[j].weight;
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
        }
    }
  
    // Step 3: check for negative-weight cycles.  The above step
    // guarantees shortest distances if graph doesn't contain
    // negative weight cycle.  If we get a shorter path, then there
    // is a cycle.
    for (int i = 0; i < E; i++) {
        int u = graph->edge[i].src;
        int v = graph->edge[i].dest;
        int weight = graph->edge[i].weight;
        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
            printf("Graph contains negative weight cycle");
            return; // If negative cycle is detected, simply return
        }
    }
  
    printArr(dist, V);
  
    return;
}
  
// Driver program to test above functions
int main()
{
    /* Let us create the graph given in above example */
    int V = 5; // Number of vertices in graph
    int E = 8; // Number of edges in graph
    struct Graph* graph = createGraph(V, E);
  
    // add edge 0-1 (or A-B in above figure)
    graph->edge[0].src = 0;
    graph->edge[0].dest = 1;
    graph->edge[0].weight = -1;
  
    // add edge 0-2 (or A-C in above figure)
    graph->edge[1].src = 0;
    graph->edge[1].dest = 2;
    graph->edge[1].weight = 4;
  
    // add edge 1-2 (or B-C in above figure)
    graph->edge[2].src = 1;
    graph->edge[2].dest = 2;
    graph->edge[2].weight = 3;
  
    // add edge 1-3 (or B-D in above figure)
    graph->edge[3].src = 1;
    graph->edge[3].dest = 3;
    graph->edge[3].weight = 2;
  
    // add edge 1-4 (or A-E in above figure)
    graph->edge[4].src = 1;
    graph->edge[4].dest = 4;
    graph->edge[4].weight = 2;
  
    // add edge 3-2 (or D-C in above figure)
    graph->edge[5].src = 3;
    graph->edge[5].dest = 2;
    graph->edge[5].weight = 5;
  
    // add edge 3-1 (or D-B in above figure)
    graph->edge[6].src = 3;
    graph->edge[6].dest = 1;
    graph->edge[6].weight = 1;
  
    // add edge 4-3 (or E-D in above figure)
    graph->edge[7].src = 4;
    graph->edge[7].dest = 3;
    graph->edge[7].weight = -3;
  
    BellmanFord(graph, 0);
  
    return 0;
}

4. Floyd Warshall Algorithm :-
  -------------------------------
  
  #include <bits/stdc++.h>
using namespace std;
 
// Number of vertices in the graph
#define V 4
 
/* Define Infinite as a large enough
value.This value will be used for
vertices not connected to each other */
#define INF 99999
 
// A function to print the solution matrix
void printSolution(int dist[][V]);
 
// Solves the all-pairs shortest path
// problem using Floyd Warshall algorithm
void floydWarshall(int graph[][V])
{
    /* dist[][] will be the output matrix
    that will finally have the shortest
    distances between every pair of vertices */
    int dist[V][V], i, j, k;
 
    /* Initialize the solution matrix same
    as input graph matrix. Or we can say
    the initial values of shortest distances
    are based on shortest paths considering
    no intermediate vertex. */
    for (i = 0; i < V; i++)
        for (j = 0; j < V; j++)
            dist[i][j] = graph[i][j];
 
    /* Add all vertices one by one to
    the set of intermediate vertices.
    ---> Before start of an iteration,
    we have shortest distances between all
    pairs of vertices such that the
    shortest distances consider only the
    vertices in set {0, 1, 2, .. k-1} as
    intermediate vertices.
    ----> After the end of an iteration,
    vertex no. k is added to the set of
    intermediate vertices and the set becomes {0, 1, 2, ..
    k} */
    for (k = 0; k < V; k++) {
        // Pick all vertices as source one by one
        for (i = 0; i < V; i++) {
            // Pick all vertices as destination for the
            // above picked source
            for (j = 0; j < V; j++) {
                // If vertex k is on the shortest path from
                // i to j, then update the value of
                // dist[i][j]
                if (dist[i][j] > (dist[i][k] + dist[k][j])
                    && (dist[k][j] != INF
                        && dist[i][k] != INF))
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
 
    // Print the shortest distance matrix
    printSolution(dist);
}
 
/* A utility function to print solution */
void printSolution(int dist[][V])
{
    cout << "The following matrix shows the shortest "
            "distances"
            " between every pair of vertices \n";
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (dist[i][j] == INF)
                cout << "INF"
                     << "     ";
            else
                cout << dist[i][j] << "     ";
        }
        cout << endl;
    }
}
 
// Driver code
int main()
{
    /* Let us create the following weighted graph
            10
    (0)------->(3)
        |     /|\
    5 |     |
        |     | 1
    \|/     |
    (1)------->(2)
            3     */
    int graph[V][V] = { { 0, 5, INF, 10 },
                        { INF, 0, 3, INF },
                        { INF, INF, 0, 1 },
                        { INF, INF, INF, 0 } };
 
    // Print the solution
    floydWarshall(graph);
    return 0;
}

5. MST using Prim’s Algo :-
  ----------------------------
  
  #include <bits/stdc++.h>
using namespace std;
  
// Number of vertices in the graph 
#define V 5 
  
// A utility function to find the vertex with 
// minimum key value, from the set of vertices 
// not yet included in MST 
int minKey(int key[], bool mstSet[]) 
{ 
    // Initialize min value 
    int min = INT_MAX, min_index; 
  
    for (int v = 0; v < V; v++) 
        if (mstSet[v] == false && key[v] < min) 
            min = key[v], min_index = v; 
  
    return min_index; 
} 
  
// A utility function to print the 
// constructed MST stored in parent[] 
void printMST(int parent[], int graph[V][V]) 
{ 
    cout<<"Edge \tWeight\n"; 
    for (int i = 1; i < V; i++) 
        cout<<parent[i]<<" - "<<i<<" \t"<<graph[i][parent[i]]<<" \n"; 
} 
  
// Function to construct and print MST for 
// a graph represented using adjacency 
// matrix representation 
void primMST(int graph[V][V]) 
{ 
    // Array to store constructed MST 
    int parent[V]; 
      
    // Key values used to pick minimum weight edge in cut 
    int key[V]; 
      
    // To represent set of vertices included in MST 
    bool mstSet[V]; 
  
    // Initialize all keys as INFINITE 
    for (int i = 0; i < V; i++) 
        key[i] = INT_MAX, mstSet[i] = false; 
  
    // Always include first 1st vertex in MST. 
    // Make key 0 so that this vertex is picked as first vertex. 
    key[0] = 0; 
    parent[0] = -1; // First node is always root of MST 
  
    // The MST will have V vertices 
    for (int count = 0; count < V - 1; count++)
    { 
        // Pick the minimum key vertex from the 
        // set of vertices not yet included in MST 
        int u = minKey(key, mstSet); 
  
        // Add the picked vertex to the MST Set 
        mstSet[u] = true; 
  
        // Update key value and parent index of 
        // the adjacent vertices of the picked vertex. 
        // Consider only those vertices which are not 
        // yet included in MST 
        for (int v = 0; v < V; v++) 
  
            // graph[u][v] is non zero only for adjacent vertices of m 
            // mstSet[v] is false for vertices not yet included in MST 
            // Update the key only if graph[u][v] is smaller than key[v] 
            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) 
                parent[v] = u, key[v] = graph[u][v]; 
    } 
  
    // print the constructed MST 
    printMST(parent, graph); 
} 
  
// Driver code
int main() 
{ 
    /* Let us create the following graph 
        2 3 
    (0)--(1)--(2) 
    | / \ | 
    6| 8/ \5 |7 
    | / \ | 
    (3)-------(4) 
            9     */
    int graph[V][V] = { { 0, 2, 0, 6, 0 }, 
                        { 2, 0, 3, 8, 5 }, 
                        { 0, 3, 0, 0, 7 }, 
                        { 6, 8, 0, 0, 9 }, 
                        { 0, 5, 7, 9, 0 } }; 
  
    // Print the solution 
    primMST(graph); 
  
    return 0; 
} 

6. MST using Kruskal’s Algo :-
  ------------------------------

#include <iostream>
using namespace std;

class Edge{
	public:
	int source;
	int dest;
	int weight;
};
bool compare(Edge e1, Edge e2){
	return e1.weight<e2.weight;
}

int findParent(int v, int *parent){
	if(parent[v]==v){
		return v;
	}
	return findParent(parent[v],parent);
}
void kruskals(Edge *input,int n,int E){
	sort(input,input+E,compare);
	
	Edge *output = new Edge(n-1);
	int *parent =new int[n];
	for(int i=0;i<n;i++){
		parent[i]=i;
	}
	int count=0;
	int i=0;
	while(count!=n-1){
		Edge currentEdge = input[i];
		int sourceParent=findParent(currentEdge.source,parent);
		int destParent=findParent(currentEdge.dest, parent);
		if(sourceParent!=destParent){
			output[count] =currentEdge;
			count++;
		}
		i++;
	}
	
	for(int i=0;i<=n-1;i++){
		if(output[i].source<output[i].dest){
			cout<<output[i].source<<" "<<output[i].dest<<" "<<output[i].weight<<endl;
		}
		else{
			cout<<output[i].dest<<" "<<output[i].source<<" "<<output[i].weight<<endl;
		}
	}
}

int main(){
	int n,E;
	cin>>n>>E;
	Edge *input=new Edge[E];
	for(int i=0;i<E;i++){
		int s,d,w;
		cin>>s>>d>>w;
		input[i].source=s;
		input[i].dest=d;
		input[i].weight=w;
	}
	kruskals(Edge,n,E);
}

Day25: (Dynamic Programming) 
------------------------------

1. Max Product Subarray :-
  ---------------------------
  #include <bits/stdc++.h>
using namespace std;
 
/* Returns the product
  of max product subarray.
Assumes that the given
array always has a subarray
with product more than 1 */
int maxSubarrayProduct(int arr[], int n)
{
    // max positive product
    // ending at the current position
    int max_ending_here = 1;
 
    // min negative product ending
    // at the current position
    int min_ending_here = 1;
 
    // Initialize overall max product
    int max_so_far = 0;
    int flag = 0;
    /* Traverse through the array.
    Following values are
    maintained after the i'th iteration:
    max_ending_here is always 1 or
    some positive product ending with arr[i]
    min_ending_here is always 1 or
    some negative product ending with arr[i] */
    for (int i = 0; i < n; i++)
    {
        /* If this element is positive, update
        max_ending_here. Update min_ending_here only if
        min_ending_here is negative */
        if (arr[i] > 0)
        {
            max_ending_here = max_ending_here * arr[i];
            min_ending_here
                = min(min_ending_here * arr[i], 1);
            flag = 1;
        }
 
        /* If this element is 0, then the maximum product
        cannot end here, make both max_ending_here and
        min_ending_here 0
        Assumption: Output is alway greater than or equal
                    to 1. */
        else if (arr[i] == 0) {
            max_ending_here = 1;
            min_ending_here = 1;
        }
 
        /* If element is negative. This is tricky
         max_ending_here can either be 1 or positive.
         min_ending_here can either be 1 or negative.
         next max_ending_here will always be prev.
         min_ending_here * arr[i] ,next min_ending_here
         will be 1 if prev max_ending_here is 1, otherwise
         next min_ending_here will be prev max_ending_here *
         arr[i] */
 
        else {
            int temp = max_ending_here;
            max_ending_here
                = max(min_ending_here * arr[i], 1);
            min_ending_here = temp * arr[i];
        }
 
        // update max_so_far, if needed
        if (max_so_far < max_ending_here)
            max_so_far = max_ending_here;
    }
    if (flag == 0 && max_so_far == 0)
        return 0;
    return max_so_far;
}
 
// Driver code
int main()
{
    int arr[] = { 1, -2, -3, 0, 7, -8, -2 };
    int n = sizeof(arr) / sizeof(arr[0]);
    cout << "Maximum Sub array product is "
         << maxSubarrayProduct(arr, n);
    return 0;
}
  